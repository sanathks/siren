<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Siren - Mermaid + Visual Diagram Editor</title>
  <meta name="description" content="The best of both worlds: Mermaid syntax + visual editing. Create, edit, and share diagrams instantly.">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon-180.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            storm: {
              bg: '#1a1b26',
              bg2: '#24283b',
              fg: '#a9b1d6',
              accent: '#7aa2f7',
              green: '#9ece6a',
              red: '#f7768e',
              yellow: '#e0af68',
              purple: '#bb9af7',
              cyan: '#7dcfff',
              orange: '#ff9e64',
            }
          }
        }
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { background: #1a1b26; overflow: hidden; }
    .node { cursor: move; user-select: none; }
    .node:hover .node-border { stroke-width: 2.5; }
    .node.selected .node-border { stroke: #7aa2f7; stroke-width: 2.5; }
    .connector { cursor: crosshair; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
    .node:hover .connector { opacity: 0.4; pointer-events: auto; }
    .show-connectors .connector { opacity: 0.4; pointer-events: auto; }
    .show-connectors .lifeline-connector { opacity: 0.6; pointer-events: auto; }
    .connector:hover { opacity: 1; fill: #7aa2f7 !important; }
    .lifeline-connector { opacity: 0; transition: opacity 0.15s, transform 0.15s; pointer-events: auto; }
    .node:hover .lifeline-connector { opacity: 0.5; }
    .lifeline-connector:hover { opacity: 1 !important; }
    .connection { pointer-events: stroke; cursor: pointer; stroke-linecap: round; }
    .connection-group { cursor: pointer; }
    .conn-hit { pointer-events: stroke; cursor: pointer; }
    .connection-group:hover path.connection { stroke-width: 2.5 !important; }
    .connection-group.selected path.connection { stroke-width: 3; stroke: #7aa2f7 !important; }
    .container-fill { pointer-events: none; }
    .resize-handle { cursor: se-resize; opacity: 0; }
    .node.selected .resize-handle { opacity: 1; }
    
    .tool-btn { 
      width: 36px; height: 36px; 
      display: flex; align-items: center; justify-content: center;
      background: transparent; border: none; border-radius: 8px;
      color: #a9b1d6; cursor: pointer; transition: all 0.15s;
    }
    .tool-btn:hover { background: rgba(122, 162, 247, 0.15); }
    .tool-btn.active { background: #7aa2f7; color: #1a1b26; }
    .tool-btn svg { width: 20px; height: 20px; }
    .divider { width: 1px; height: 24px; background: #414868; margin: 0 4px; }
    .dropdown { position: relative; }
    .dropdown-menu { 
      position: absolute; top: 44px; left: 50%; transform: translateX(-50%);
      background: #24283b; border: 1px solid #414868; border-radius: 8px;
      padding: 6px; min-width: 120px; z-index: 100; display: none;
    }
    .dropdown.open .dropdown-menu { display: block; }
    .dropdown-item {
      display: flex; align-items: center; gap: 8px; padding: 8px 12px;
      border-radius: 6px; cursor: pointer; color: #a9b1d6; font-size: 13px;
      white-space: nowrap;
    }
    .dropdown-item:hover { background: rgba(122, 162, 247, 0.15); }
    
    /* Cursor styles for drawing modes */
    .canvas-draw { cursor: crosshair; }
  </style>
</head>
<body class="h-screen flex flex-col">
  <!-- Top Toolbar -->
  <header class="h-14 bg-storm-bg2 border-b border-storm-bg flex items-center px-4 z-20">
    <!-- Left: Logo -->
    <div class="flex items-center">
      <img src="favicon-32.png" alt="Siren" style="width:28px;height:28px;margin-right:8px">
    </div>
    
    <!-- Center: All Tools -->
    <div class="flex-1 flex justify-center">
      <div class="flex items-center gap-1 bg-storm-bg rounded-lg p-1">
        <!-- Undo/Redo -->
        <button class="tool-btn" onclick="undo()" title="Undo (Cmd+Z)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 10h10a5 5 0 1 1 0 10H9"/><polyline points="7 6 3 10 7 14"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="redo()" title="Redo (Cmd+Shift+Z)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 10h-10a5 5 0 1 0 0 10h4"/><polyline points="17 6 21 10 17 14"/>
          </svg>
        </button>
        <div class="divider"></div>
        <!-- Select tool -->
        <button class="tool-btn active" id="tool-select" onclick="setTool('select')" title="Select (V)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/>
          </svg>
        </button>
        <div class="divider"></div>
        <!-- Shape tools -->
        <button class="tool-btn" id="tool-rect" onclick="setTool('rect')" title="Rectangle (1)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
        </button>
        <button class="tool-btn" id="tool-pill" onclick="setTool('pill')" title="Pill (2)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
        </button>
        <button class="tool-btn" id="tool-diamond" onclick="setTool('diamond')" title="Diamond (3)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12,2 22,12 12,22 2,12"/></svg>
        </button>
        <button class="tool-btn" id="tool-circle" onclick="setTool('circle')" title="Circle (4)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>
        </button>
        <button class="tool-btn" id="tool-container" onclick="setTool('container')" title="Container (5)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2" stroke-dasharray="4"/></svg>
        </button>
        <button class="tool-btn" id="tool-text" onclick="setTool('text')" title="Text (T)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
        </button>
        <button class="tool-btn" id="tool-line" onclick="setTool('line')" title="Arrow Line (6)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="5" y1="19" x2="19" y2="5"/>
            <polyline points="12 5 19 5 19 12"/>
          </svg>
        </button>
        <!-- Arrange -->
        <button class="tool-btn" onclick="arrangeDiagram()" title="Auto-Arrange (A)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="6" height="6" rx="1"/><rect x="15" y="3" width="6" height="6" rx="1"/>
            <rect x="9" y="15" width="6" height="6" rx="1"/>
            <path d="M6 9v3h3M18 9v3h-3M12 15v-3"/>
          </svg>
        </button>
        <!-- Code toggle -->
        <button id="mermaidToggle" class="tool-btn" onclick="toggleMermaidSidebar()" title="Mermaid Code (M)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/>
          </svg>
        </button>
        <div class="divider"></div>
        <!-- Line style -->
        <div class="dropdown" id="lineDropdown">
          <button class="tool-btn" onclick="toggleDropdown('lineDropdown')" title="Line Style (7)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 12 C8 12, 8 6, 12 6 C16 6, 16 12, 20 12"/>
            </svg>
          </button>
          <div class="dropdown-menu">
            <div class="dropdown-item" data-line="rounded" onclick="setGlobalLineStyle('rounded')">↪ Rounded</div>
            <div class="dropdown-item" data-line="straight" onclick="setGlobalLineStyle('straight')">⌐ Straight</div>
          </div>
        </div>
        <!-- Grid toggle -->
        <button class="tool-btn active" id="gridTool" onclick="toggleGrid()" title="Snap to Grid (8)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
            <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
          </svg>
        </button>
        <div class="divider"></div>
        <!-- Export -->
        <div class="dropdown" id="exportDropdown">
          <button class="tool-btn" onclick="toggleDropdown('exportDropdown')" title="Export (9)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
          </button>
          <div class="dropdown-menu">
            <div class="dropdown-item" onclick="downloadPNG();closeDropdowns()">PNG</div>
            <div class="dropdown-item" onclick="downloadSVG();closeDropdowns()">SVG</div>
          </div>
        </div>
        <!-- Share -->
        <button class="tool-btn" onclick="shareDiagram()" title="Copy Share Link (0)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
          </svg>
        </button>
        <!-- Clear -->
        <button class="tool-btn" onclick="clearCanvas()" title="Clear Canvas">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Right: empty for balance -->
    <div class="flex items-center" style="width:32px"></div>
  </header>
  
  <!-- Main container with sidebar + canvas -->
  <main class="flex-1 flex overflow-hidden">
    <!-- Mermaid Code Sidebar (Left) -->
    <div id="mermaidSidebar" class="hidden" style="width:320px;background:#1a1b26;border-right:1px solid #414868;display:flex;flex-direction:column">
      <div style="padding:8px 12px;border-bottom:1px solid #414868;display:flex;align-items:center;justify-content:space-between">
        <span style="font-size:12px;font-weight:600;color:#a9b1d6">Mermaid</span>
        <div style="display:flex;gap:4px;align-items:center">
          <button onclick="exportMermaid()" style="padding:4px 8px;background:#24283b;border:1px solid #414868;border-radius:4px;font-size:10px;font-weight:600;color:#a9b1d6;cursor:pointer" title="Export diagram to code">Export</button>
          <button onclick="importMermaid()" style="padding:4px 8px;background:#7aa2f7;border:none;border-radius:4px;font-size:10px;font-weight:600;color:#1a1b26;cursor:pointer" title="Import code to diagram (Ctrl+Enter)">Import</button>
          <button onclick="toggleMermaidSidebar()" title="Close (M)" style="width:24px;height:24px;background:transparent;border:1px solid #414868;border-radius:4px;font-size:12px;color:#a9b1d6;cursor:pointer">✕</button>
        </div>
      </div>
      <textarea id="mermaidEditor" spellcheck="false" placeholder="flowchart TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action]
    B -->|No| D[End]" style="flex:1;background:#24283b;color:#a9b1d6;border:none;padding:12px;font-family:monospace;font-size:12px;line-height:1.5;resize:none;outline:none"></textarea>
      <div id="mermaidError" style="display:none;padding:8px 12px;background:rgba(247,118,142,0.1);border-top:1px solid #f7768e;font-size:11px;color:#f7768e"></div>
      <div style="padding:8px 12px;border-top:1px solid #414868;font-size:10px;color:#565f89">
        <strong>Shapes:</strong> [rect] (pill) {diamond} ((circle))<br>
        <strong>Connect:</strong> A --> B or A -->|label| B
      </div>
    </div>
    
    <!-- Canvas area -->
    <div id="canvasContainer" class="flex-1 relative overflow-hidden">
    <svg id="canvas" class="w-full h-full" style="background: #1a1b26;">
      <defs>
        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
          <circle cx="10" cy="10" r="0.5" fill="#414868" opacity="0.5"/>
        </pattern>
        <pattern id="stripe" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(-45)">
          <line x1="0" y1="0" x2="0" y2="8" stroke="#a9b1d6" stroke-width="2" opacity="0.15"/>
        </pattern>
        <pattern id="grid-fill" width="10" height="10" patternUnits="userSpaceOnUse">
          <circle cx="5" cy="5" r="0.5" fill="#a9b1d6" opacity="0.5"/>
        </pattern>
      </defs>
      <rect id="gridBg" width="5000" height="5000" x="-2500" y="-2500" fill="url(#grid)"/>
      <rect id="selectBox" fill="rgba(122, 162, 247, 0.1)" stroke="#7aa2f7" stroke-width="1" stroke-dasharray="4" style="display:none"/>
      <rect id="drawPreview" fill="rgba(122, 162, 247, 0.1)" stroke="#7aa2f7" stroke-width="1.5" stroke-dasharray="4" rx="4" style="display:none"/>
      <g id="viewport">
        <g id="connections"></g>
        <g id="nodes"></g>
      </g>
    </svg>
    
    <!-- Temp line for drawing connections -->
    <svg id="tempLine" class="absolute inset-0 w-full h-full pointer-events-none z-10" style="display:none;">
      <path id="tempPath" fill="none" stroke="#7aa2f7" stroke-width="2"/>
    </svg>
    
    <!-- Zoom indicator -->
    <div class="absolute bottom-4 right-4 bg-storm-bg2/80 backdrop-blur px-3 py-1 rounded text-sm text-storm-fg/60">
      <span id="zoomLevel">100%</span>
    </div>
    
    <!-- Keyboard hints -->
    <div class="absolute bottom-4 left-4 text-xs text-storm-fg/30 space-y-0.5">
      <div><kbd class="bg-storm-bg2 px-1 py-0.5 rounded">V</kbd> Select <kbd class="bg-storm-bg2 px-1 py-0.5 rounded">1-5</kbd> Shapes <kbd class="bg-storm-bg2 px-1 py-0.5 rounded">T</kbd> Text <kbd class="bg-storm-bg2 px-1 py-0.5 rounded">6</kbd> Arrow</div>
      <div>Click+drag to draw • Drag from edge to quick-connect</div>
    </div>
    
    <!-- Floating toolbar for selected node -->
    <div id="floatingToolbar" class="absolute hidden bg-storm-bg2 border border-storm-fg/20 rounded-lg shadow-xl px-3 py-2 z-30" style="white-space:nowrap">
      <div class="flex items-center gap-3">
        <input type="text" id="toolbarLabel" placeholder="Label" tabindex="1"
          class="bg-storm-bg border border-storm-fg/20 rounded px-2 py-1 text-xs text-storm-fg" style="width:80px">
        
        <!-- Shape changer dropdown -->
        <div class="relative" style="display:inline-block">
          <button id="shapeBtn" onclick="toggleShapeDropdown()" class="flex items-center justify-center" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;color:#a9b1d6" title="Change Shape">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
          </button>
          <div id="shapeDropdown" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:0;padding:4px;min-width:90px">
            <button onclick="changeShape('rect');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><rect x="3" y="3" width="18" height="18" rx="2"/></svg> Rect
            </button>
            <button onclick="changeShape('pill');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><rect x="2" y="6" width="20" height="12" rx="6"/></svg> Pill
            </button>
            <button onclick="changeShape('diamond');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><polygon points="12,2 22,12 12,22 2,12"/></svg> Diamond
            </button>
            <button onclick="changeShape('circle');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><circle cx="12" cy="12" r="10"/></svg> Circle
            </button>
            <button onclick="changeShape('container');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><rect x="2" y="2" width="20" height="20" rx="2" stroke-dasharray="4"/></svg> Container
            </button>
            <button onclick="changeShape('text');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg> Text
            </button>
            <button onclick="changeShape('line');closeShapeDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="12 5 19 5 19 12"/></svg> Arrow
            </button>
          </div>
        </div>
        
        <!-- Fill style dropdown (hidden for line nodes) -->
        <div id="fillStyleGroup" class="relative" style="display:inline-block">
          <button id="fillStyleBtn" onclick="toggleFillDropdown()" class="flex items-center justify-center" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;font-size:16px;color:#a9b1d6" title="Fill Style">●</button>
          <div id="fillDropdown" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:0;padding:4px">
            <button onclick="setFillStyle('outline');closeFillDropdown()" class="fill-style-btn block w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:4px 8px" data-style="outline">○ Outline</button>
            <button onclick="setFillStyle('infill');closeFillDropdown()" class="fill-style-btn block w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:4px 8px" data-style="infill">● Infill</button>
            <button onclick="setFillStyle('stripe');closeFillDropdown()" class="fill-style-btn block w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:4px 8px" data-style="stripe">▤ Stripe</button>
            <button onclick="setFillStyle('grid');closeFillDropdown()" class="fill-style-btn block w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:4px 8px" data-style="grid">▦ Grid</button>
          </div>
        </div>
        
        <!-- Fill color (hidden for line nodes) -->
        <div id="fillColorGroup" class="relative" style="display:inline-block">
          <button id="fillColorBtn" onclick="toggleFillColorPalette()" title="Fill Color" style="width:24px;height:24px;border-radius:50%;background:#24283b;border:2px solid #414868"></button>
          <div id="fillColorPalette" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:50%;transform:translateX(-50%);padding:8px">
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px">
              <button onclick="setNodeColor('');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#24283b;border:2px solid #414868"></button>
              <button onclick="setNodeColor('#7aa2f7');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#7aa2f7;border:none"></button>
              <button onclick="setNodeColor('#9ece6a');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#9ece6a;border:none"></button>
              <button onclick="setNodeColor('#f7768e');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#f7768e;border:none"></button>
              <button onclick="setNodeColor('#e0af68');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#e0af68;border:none"></button>
              <button onclick="setNodeColor('#bb9af7');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#bb9af7;border:none"></button>
              <button onclick="setNodeColor('#7dcfff');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#7dcfff;border:none"></button>
              <button onclick="setNodeColor('#ff9e64');closeFillColorPalette()" style="width:22px;height:22px;border-radius:50%;background:#ff9e64;border:none"></button>
            </div>
          </div>
        </div>
        
        <!-- Line style dropdown (only for line nodes) -->
        <div id="lineStyleGroup" class="relative hidden" style="display:none">
          <button id="lineStyleBtn" onclick="toggleLineStyleDropdown()" class="flex items-center justify-center" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;color:#a9b1d6" title="Line Style">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px"><line x1="4" y1="12" x2="20" y2="12"/></svg>
          </button>
          <div id="lineStyleDropdown" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:0;padding:4px;min-width:80px">
            <button onclick="setLineStyle('solid');closeLineStyleDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:8px"><line x1="0" y1="4" x2="24" y2="4"/></svg> Solid
            </button>
            <button onclick="setLineStyle('dashed');closeLineStyleDropdown()" class="flex items-center gap-2 w-full text-left text-xs text-storm-fg hover:bg-storm-accent/20 rounded" style="padding:6px 8px">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="4,2" style="width:16px;height:8px"><line x1="0" y1="4" x2="24" y2="4"/></svg> Dashed
            </button>
          </div>
        </div>
        
        <!-- Outline color -->
        <div class="relative" style="display:inline-block">
          <button id="outlineColorBtn" onclick="toggleOutlineColorPalette()" title="Outline Color" style="width:24px;height:24px;border-radius:50%;background:transparent;border:3px solid #a9b1d6"></button>
          <div id="outlineColorPalette" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:50%;transform:translateX(-50%);padding:8px">
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px">
              <button onclick="setOutlineColor('');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #414868"></button>
              <button onclick="setOutlineColor('#7aa2f7');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #7aa2f7"></button>
              <button onclick="setOutlineColor('#9ece6a');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #9ece6a"></button>
              <button onclick="setOutlineColor('#f7768e');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #f7768e"></button>
              <button onclick="setOutlineColor('#e0af68');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #e0af68"></button>
              <button onclick="setOutlineColor('#bb9af7');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #bb9af7"></button>
              <button onclick="setOutlineColor('#7dcfff');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #7dcfff"></button>
              <button onclick="setOutlineColor('#ff9e64');closeOutlineColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #ff9e64"></button>
            </div>
          </div>
        </div>
        
        <!-- Lifeline toggle (for sequence diagrams) -->
        <button id="lifelineToggle" onclick="toggleLifeline()" title="Toggle Lifeline (Sequence Diagram)" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;color:#a9b1d6;display:flex;align-items:center;justify-content:center">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
            <rect x="6" y="2" width="12" height="6" rx="1"/>
            <line x1="12" y1="8" x2="12" y2="22" stroke-dasharray="3,2"/>
          </svg>
        </button>
        
        <button onclick="deleteSelected()" title="Delete" style="width:28px;height:28px;background:rgba(247,118,142,0.2);border:none;border-radius:4px;color:#f7768e;display:flex;align-items:center;justify-content:center">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
            <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
        <button onclick="deselectAll()" title="Close" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;font-size:14px;color:#a9b1d6;cursor:pointer">✕</button>
      </div>
    </div>
    
    <!-- Floating toolbar for selected connection -->
    <div id="connToolbar" class="absolute hidden bg-storm-bg2 border border-storm-fg/20 rounded-lg shadow-xl px-3 py-2 z-30" style="white-space:nowrap">
      <div class="flex items-center gap-3">
        <input type="text" id="connLabel" placeholder="Label" 
          class="bg-storm-bg border border-storm-fg/20 rounded px-2 py-1 text-xs text-storm-fg" style="width:80px">
        
        <!-- Line color -->
        <div class="relative" style="display:inline-block">
          <button id="connColorBtn" onclick="toggleConnColorPalette()" title="Line Color" style="width:24px;height:24px;border-radius:50%;background:transparent;border:3px solid #a9b1d6"></button>
          <div id="connColorPalette" class="hidden absolute bg-storm-bg2 border border-storm-fg/20 rounded shadow-lg z-50" style="top:32px;left:50%;transform:translateX(-50%);padding:8px">
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px">
              <button onclick="setConnColor('');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #a9b1d6"></button>
              <button onclick="setConnColor('#7aa2f7');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #7aa2f7"></button>
              <button onclick="setConnColor('#9ece6a');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #9ece6a"></button>
              <button onclick="setConnColor('#f7768e');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #f7768e"></button>
              <button onclick="setConnColor('#e0af68');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #e0af68"></button>
              <button onclick="setConnColor('#bb9af7');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #bb9af7"></button>
              <button onclick="setConnColor('#7dcfff');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #7dcfff"></button>
              <button onclick="setConnColor('#ff9e64');closeConnColorPalette()" style="width:22px;height:22px;border-radius:50%;background:transparent;border:3px solid #ff9e64"></button>
            </div>
          </div>
        </div>
        
        <!-- Line style: solid/dotted -->
        <div class="flex items-center gap-1">
          <button id="connSolidBtn" onclick="setConnLineStyle('solid')" title="Solid line" style="width:28px;height:28px;background:#1a1b26;border:2px solid transparent;border-radius:4px;display:flex;align-items:center;justify-content:center">
            <svg viewBox="0 0 24 6" style="width:20px;height:6px"><line x1="2" y1="3" x2="22" y2="3" stroke="#a9b1d6" stroke-width="2"/></svg>
          </button>
          <button id="connDottedBtn" onclick="setConnLineStyle('dashed')" title="Dotted line" style="width:28px;height:28px;background:#1a1b26;border:2px solid transparent;border-radius:4px;display:flex;align-items:center;justify-content:center">
            <svg viewBox="0 0 24 6" style="width:20px;height:6px"><line x1="2" y1="3" x2="22" y2="3" stroke="#a9b1d6" stroke-width="2" stroke-dasharray="4,3"/></svg>
          </button>
        </div>
        
        <button onclick="deleteSelectedConn()" title="Delete" style="width:28px;height:28px;background:rgba(247,118,142,0.2);border:none;border-radius:4px;color:#f7768e;display:flex;align-items:center;justify-content:center">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
            <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
        <button onclick="deselectConn()" title="Close" style="width:28px;height:28px;background:#1a1b26;border:1px solid #414868;border-radius:4px;font-size:14px;color:#a9b1d6;cursor:pointer">✕</button>
      </div>
    </div>
    </div><!-- end canvasContainer -->
  </main>

  <script>
    // State
    let nodes = [];
    let connections = [];
    let sequenceFrames = []; // For sequence diagram loop/alt frames
    let selectedId = null;
    let selectedIds = [];
    let selectedConnId = null;
    let currentTool = 'select'; // select, rect, pill, diamond, circle, container, arrow
    let drawing = null; // { startX, startY, type }
    let dragging = null;
    let connecting = null;
    let panning = false;
    let panStart = { x: 0, y: 0 };
    let selecting = null;
    let viewBox = { x: 0, y: 0, w: 0, h: 0 };
    let zoom = 1;
    let idCounter = 0;
    let historyStack = [];
    let historyIndex = -1;
    let snapToGrid = true;
    let clipboard = null;
    let globalLineStyle = 'rounded';
    
    const canvas = document.getElementById('canvas');
    const nodesGroup = document.getElementById('nodes');
    const connectionsGroup = document.getElementById('connections');
    const tempLine = document.getElementById('tempLine');
    const tempPath = document.getElementById('tempPath');
    
    // Sync tempLine viewBox with canvas for proper coordinate mapping
    function showTempLine() {
      tempLine.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      tempLine.style.display = 'block';
    }
    function hideTempLine() {
      tempLine.style.display = 'none';
      tempPath.setAttribute('d', '');
    }
    const zoomLevel = document.getElementById('zoomLevel');
    const gridBg = document.getElementById('gridBg');
    const drawPreview = document.getElementById('drawPreview');
    const selectBox = document.getElementById('selectBox');
    const floatingToolbar = document.getElementById('floatingToolbar');
    const toolbarLabel = document.getElementById('toolbarLabel');
    
    const COLORS = { bg: '#1a1b26', bg2: '#24283b', fg: '#a9b1d6', accent: '#7aa2f7', border: '#414868' };
    const GRID_SIZE = 20;
    const SHAPE_TOOLS = ['rect', 'pill', 'diamond', 'circle', 'container', 'text', 'line'];
    
    // Tool management
    function setTool(tool) {
      currentTool = tool;
      // Update toolbar buttons
      document.querySelectorAll('[id^="tool-"]').forEach(btn => btn.classList.remove('active'));
      document.getElementById('tool-' + tool)?.classList.add('active');
      // Update cursor
      const container = document.getElementById('canvasContainer');
      if (SHAPE_TOOLS.includes(tool)) {
        container.classList.add('canvas-draw');
      } else {
        container.classList.remove('canvas-draw');
      }
      canvas.classList.remove('show-connectors');
      // Deselect when switching to draw tool
      if (tool !== 'select') deselectAll();
    }
    
    // Dropdown management
    function toggleDropdown(id) {
      const dropdown = document.getElementById(id);
      const wasOpen = dropdown.classList.contains('open');
      closeDropdowns();
      if (!wasOpen) dropdown.classList.add('open');
    }
    function closeDropdowns() {
      document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
    }
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.dropdown')) closeDropdowns();
    });
    
    // Grid toggle
    function toggleGrid() {
      snapToGrid = !snapToGrid;
      document.getElementById('gridTool').classList.toggle('active', snapToGrid);
      gridBg.style.display = snapToGrid ? 'block' : 'none';
    }
    
    // Initialize
    function init() {
      const rect = canvas.getBoundingClientRect();
      viewBox = { x: 0, y: 0, w: rect.width, h: rect.height };
      updateViewBox();
      loadFromUrl();
      saveState();
      render();
      setGlobalLineStyle('rounded');
    }
    
    function generateId() { return 'n' + (++idCounter); }
    function snap(val) { return snapToGrid ? Math.round(val / GRID_SIZE) * GRID_SIZE : val; }
    
    function saveState() {
      historyStack = historyStack.slice(0, historyIndex + 1);
      historyStack.push(JSON.stringify({ nodes, connections }));
      historyIndex++;
      if (historyStack.length > 50) { historyStack.shift(); historyIndex--; }
      updateUrlHash();
    }
    
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = JSON.parse(historyStack[historyIndex]);
        nodes = state.nodes;
        connections = state.connections;
        render();
        updateUrlHash();
      }
    }
    
    function redo() {
      if (historyIndex < historyStack.length - 1) {
        historyIndex++;
        const state = JSON.parse(historyStack[historyIndex]);
        nodes = state.nodes;
        connections = state.connections;
        render();
        updateUrlHash();
      }
    }
    
    function updateUrlHash() {
      if (nodes.length === 0 && connections.length === 0) {
        history.replaceState(null, '', window.location.pathname);
        return;
      }
      // Save viewport position along with diagram data
      const data = { n: nodes, c: connections, v: { x: viewBox.x, y: viewBox.y, z: zoom } };
      const json = JSON.stringify(data);
      const encoded = btoa(encodeURIComponent(json));
      history.replaceState(null, '', '#' + encoded);
    }
    
    function loadFromUrl() {
      const hash = window.location.hash.slice(1);
      console.log('loadFromUrl called, hash length:', hash?.length || 0);
      if (!hash) return;
      try {
        const json = decodeURIComponent(atob(hash));
        const data = JSON.parse(json);
        console.log('Parsed data:', { nodesCount: data.n?.length, hasViewport: !!data.v });
        nodes = data.n || [];
        connections = data.c || [];
        idCounter = Math.max(...nodes.map(n => parseInt(n.id.slice(1)) || 0), 0) + 1;
        const rect = canvas.getBoundingClientRect();
        // Restore viewport position if saved, but verify content is visible
        let shouldAutoCenter = !data.v;
        if (data.v && nodes.length > 0) {
          // Check if saved viewport actually shows the content
          const contentMinX = Math.min(...nodes.map(n => n.x));
          const contentMaxX = Math.max(...nodes.map(n => n.x + (n.width || 120)));
          const contentMinY = Math.min(...nodes.map(n => n.y));
          const savedVx = data.v.x || 0;
          const savedVy = data.v.y || 0;
          const savedZoom = data.v.z || 1;
          const savedVw = rect.width * savedZoom;
          const savedVh = rect.height * savedZoom;
          // If content is completely outside saved viewport, auto-center instead
          if (contentMaxX < savedVx || contentMinX > savedVx + savedVw ||
              contentMinY > savedVy + savedVh) {
            shouldAutoCenter = true;
            console.log('Saved viewport misses content, auto-centering');
          }
        }
        
        if (data.v && !shouldAutoCenter) {
          viewBox.x = data.v.x || 0;
          viewBox.y = data.v.y || 0;
          zoom = data.v.z || 1;
          viewBox.w = rect.width * zoom;
          viewBox.h = rect.height * zoom;
          updateViewBox();
        } else if (nodes.length > 0) {
          // Auto-center on diagram content if no saved viewport
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          nodes.forEach(n => {
            minX = Math.min(minX, n.x);
            minY = Math.min(minY, n.y);
            maxX = Math.max(maxX, n.x + (n.width || 120));
            maxY = Math.max(maxY, n.y + (n.height || 44) + (n.hasLifeline ? 300 : 0));
          });
          // Center viewport on content
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          viewBox.x = centerX - viewBox.w / 2;
          viewBox.y = centerY - viewBox.h / 2;
          console.log('Auto-center:', { centerX, centerY, viewBox: {...viewBox}, nodes: nodes.length });
          updateViewBox();
        } else {
          console.log('No auto-center: nodes.length=', nodes.length, 'data.v=', false);
        }
      } catch (e) {
        console.error('Failed to load from URL:', e);
      }
    }
    
    function shareDiagram() {
      updateUrlHash();
      navigator.clipboard.writeText(window.location.href).then(() => {
        alert('Link copied to clipboard!');
      });
    }
    
    function updateViewBox() {
      canvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
      zoomLevel.textContent = Math.round(1/zoom * 100) + '%';
    }
    
    function screenToCanvas(x, y) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: viewBox.x + (x - rect.left) * (viewBox.w / rect.width),
        y: viewBox.y + (y - rect.top) * (viewBox.h / rect.height)
      };
    }
    
    // Create node at position with size
    function createNode(type, x, y, width, height) {
      const defaults = {
        rect: { w: 120, h: 44 },
        pill: { w: 120, h: 44 },
        diamond: { w: 80, h: 60 },
        circle: { w: 80, h: 80 },
        container: { w: 280, h: 180 },
        text: { w: 100, h: 24 },
        line: { w: 100, h: 0 }  // width = dx, height = dy from start
      };
      const def = defaults[type] || { w: 120, h: 44 };
      
      const node = {
        id: generateId(),
        type,
        x: snap(x),
        y: snap(y),
        width: Math.max(40, snap(width || def.w)),
        height: Math.max(20, snap(height || def.h)),
        label: type === 'container' ? 'Group' : type === 'text' ? 'Text' : type === 'line' ? '' : 'Node',
      };
      
      // For circle, ensure square
      if (type === 'circle') {
        const size = Math.max(node.width, node.height);
        node.width = size;
        node.height = size;
      }
      
      // Text nodes are smaller
      if (type === 'text') {
        node.width = Math.max(60, width || def.w);
        node.height = Math.max(20, height || def.h);
      }
      
      // Line/arrow - width and height represent the delta from x,y to end point
      // Can be negative to allow any direction
      if (type === 'line') {
        node.width = width || def.w;
        node.height = height || def.h;
        // No minimum size constraint for lines
      }
      
      nodes.push(node);
      return node;
    }
    
    // Smart arrow routing - auto-picks best sides
    function getOptimalSides(from, to) {
      const fromCx = from.x + from.width / 2;
      const fromCy = from.y + from.height / 2;
      const toCx = to.x + to.width / 2;
      const toCy = to.y + to.height / 2;
      
      const dx = toCx - fromCx;
      const dy = toCy - fromCy;
      
      let fromSide, toSide;
      
      // Determine best sides based on relative position
      if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal relationship
        if (dx > 0) {
          fromSide = 'right';
          toSide = 'left';
        } else {
          fromSide = 'left';
          toSide = 'right';
        }
      } else {
        // Vertical relationship
        if (dy > 0) {
          fromSide = 'bottom';
          toSide = 'top';
        } else {
          fromSide = 'top';
          toSide = 'bottom';
        }
      }
      
      return { fromSide, toSide };
    }
    
    function routeConnection(from, to, lineStyle = 'rounded') {
      // Auto-calculate optimal sides
      const { fromSide, toSide } = getOptimalSides(from, to);
      
      const [x1, y1] = getConnectorPos(from, fromSide, 1);
      const [x2, y2] = getConnectorPos(to, toSide, 1);
      
      const margin = 25;
      const points = [{ x: x1, y: y1 }];
      
      const dirs = { right: {x:1,y:0}, left: {x:-1,y:0}, bottom: {x:0,y:1}, top: {x:0,y:-1} };
      const d1 = dirs[fromSide];
      const d2 = dirs[toSide];
      
      const isHorizontal = d1.x !== 0;
      
      if (isHorizontal) {
          if (Math.abs(y1 - y2) < 5) {
            points.push({ x: x2, y: y2 });
          } else {
            const midX = (x1 + x2) / 2;
            if ((d1.x > 0 && x2 > x1) || (d1.x < 0 && x2 < x1)) {
              points.push({ x: midX, y: y1 });
              points.push({ x: midX, y: y2 });
            } else {
              const ext = d1.x > 0 ? Math.max(x1, x2) + margin : Math.min(x1, x2) - margin;
              points.push({ x: ext, y: y1 });
              points.push({ x: ext, y: y2 });
            }
            points.push({ x: x2, y: y2 });
          }
        } else {
          if (Math.abs(x1 - x2) < 5) {
            points.push({ x: x2, y: y2 });
          } else {
            const midY = (y1 + y2) / 2;
            if ((d1.y > 0 && y2 > y1) || (d1.y < 0 && y2 < y1)) {
              points.push({ x: x1, y: midY });
              points.push({ x: x2, y: midY });
            } else {
              const ext = d1.y > 0 ? Math.max(y1, y2) + margin : Math.min(y1, y2) - margin;
              points.push({ x: x1, y: ext });
              points.push({ x: x2, y: ext });
            }
            points.push({ x: x2, y: y2 });
          }
        }
      
      // Add gap before the target node (shorten the last segment)
      const gap = 8;
      const lastPt = points[points.length - 1];
      const prevPt = points[points.length - 2] || points[0];
      const dx = lastPt.x - prevPt.x;
      const dy = lastPt.y - prevPt.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > gap) {
        lastPt.x = lastPt.x - (dx / len) * gap;
        lastPt.y = lastPt.y - (dy / len) * gap;
      }
      
      return { points, fromSide, toSide, endX: x2, endY: y2 };
    }
    
    function render() {
      // First, render lifelines for sequence participants (either imported or user-toggled)
      const sequenceParticipants = nodes.filter(n => n.isParticipant || n.hasLifeline);
      const lifelineHeight = connections.some(c => c.isSequenceMessage) ? 
        Math.max(...connections.filter(c => c.isSequenceMessage).map(c => c.messageY || 0)) + 80 : 300;
      
      // Render sequence diagram frames (loop, alt, etc.)
      const messageSpacing = 50;
      // Calculate startY based on actual participant node positions
      const maxParticipantBottom = sequenceParticipants.length > 0 
        ? Math.max(...sequenceParticipants.map(n => n.y + n.height)) 
        : 140;
      const startY = maxParticipantBottom + 30;
      const framesSvg = sequenceFrames.map(frame => {
        if (frame.startIndex === undefined || frame.endIndex === undefined) return '';
        if (frame.endIndex < frame.startIndex) return '';
        
        // Find the leftmost and rightmost participants in this frame's messages
        const frameMessages = connections.filter(c => 
          c.isSequenceMessage && c.index >= frame.startIndex && c.index <= frame.endIndex
        );
        if (frameMessages.length === 0) return '';
        
        let minX = Infinity, maxX = -Infinity;
        frameMessages.forEach(msg => {
          const from = nodes.find(n => n.id === msg.from);
          const to = nodes.find(n => n.id === msg.to);
          if (from) { minX = Math.min(minX, from.x); maxX = Math.max(maxX, from.x + from.width); }
          if (to) { minX = Math.min(minX, to.x); maxX = Math.max(maxX, to.x + to.width); }
        });
        
        const frameY = startY + frame.startIndex * messageSpacing - 25;
        const frameH = (frame.endIndex - frame.startIndex + 1) * messageSpacing + 30;
        const frameX = minX - 20;
        const frameW = maxX - minX + 40;
        
        // Frame type colors
        const typeColors = { loop: '#9ece6a', alt: '#7aa2f7', opt: '#bb9af7', par: '#e0af68' };
        const frameColor = typeColors[frame.type] || COLORS.fg;
        
        // Draw frame box with label
        let frameSvg = `
          <rect x="${frameX}" y="${frameY}" width="${frameW}" height="${frameH}" 
            fill="none" stroke="${frameColor}" stroke-width="1.5" rx="4"/>
          <rect x="${frameX}" y="${frameY}" width="${frame.type.length * 8 + 16}" height="20" 
            fill="${frameColor}" rx="4"/>
          <text x="${frameX + 8}" y="${frameY + 14}" fill="#1a1b26" font-size="11" font-weight="600" font-family="system-ui, sans-serif">${frame.type}</text>
          <text x="${frameX + frame.type.length * 8 + 24}" y="${frameY + 14}" fill="${COLORS.fg}" font-size="10" font-family="system-ui, sans-serif">[${esc(frame.label || '')}]</text>
        `;
        
        // Draw section dividers for alt/else
        if (frame.sections && frame.sections.length > 1) {
          frame.sections.slice(1).forEach(section => {
            const sectionY = startY + section.startIndex * messageSpacing - 25;
            frameSvg += `
              <line x1="${frameX}" y1="${sectionY}" x2="${frameX + frameW}" y2="${sectionY}" 
                stroke="${frameColor}" stroke-width="1" stroke-dasharray="5,3"/>
              <text x="${frameX + 8}" y="${sectionY + 14}" fill="${COLORS.fg}" font-size="10" font-family="system-ui, sans-serif">[${esc(section.label || 'else')}]</text>
            `;
          });
        }
        
        return frameSvg;
      }).join('');
      
      // Connections
      connectionsGroup.innerHTML = framesSvg + connections.map(conn => {
        const from = nodes.find(n => n.id === conn.from);
        const to = nodes.find(n => n.id === conn.to);
        if (!from || !to) return '';
        
        // Sequence diagram message
        if (conn.isSequenceMessage) {
          const fromX = from.x + from.width / 2;
          const toX = to.x + to.width / 2;
          const y = conn.messageY || 150;
          const isConnSelected = selectedConnId === conn.id;
          const strokeColor = conn.color || (isConnSelected ? COLORS.accent : COLORS.fg);
          const strokeWidth = isConnSelected ? 2.5 : 1.5;
          
          // Arrow type - strokeStyle overrides arrow syntax if explicitly set
          const arrowIsDashed = conn.arrow?.includes('--');
          const isDashed = conn.strokeStyle ? conn.strokeStyle === 'dashed' : arrowIsDashed;
          const isAsync = conn.arrow?.includes(')');
          const dashArray = isDashed ? '5,3' : 'none';
          
          const aLen = 8, aWidth = 4;
          const label = conn.label || '';
          
          // Self-referencing message (same lifeline)
          if (conn.from === conn.to) {
            const loopWidth = 35;
            const loopHeight = 30;
            const startY = y;
            const endY = y + loopHeight;
            const rightX = fromX + loopWidth;
            
            // Curved loop path using bezier curves
            const loopPath = `M${fromX},${startY} C${rightX},${startY} ${rightX},${endY} ${fromX + 3},${endY}`;
            
            // Arrow pointing left at the end
            const arrowPath = `M${fromX + 3},${endY} L${fromX + 3 + aLen},${endY - aWidth} L${fromX + 3 + aLen},${endY + aWidth} Z`;
            
            // Label on the right side
            const labelX = rightX + 5;
            const labelY = startY + loopHeight / 2;
            const labelEl = label ? `
              <rect x="${labelX}" y="${labelY - 7}" width="${label.length * 7 + 8}" height="14" fill="${COLORS.bg}" rx="2" data-conn="${conn.id}" style="cursor:pointer;pointer-events:fill"/>
              <text x="${labelX + 4}" y="${labelY + 4}" fill="${COLORS.fg}" font-size="11" font-family="system-ui, sans-serif" data-conn="${conn.id}" style="cursor:pointer;pointer-events:painted">${esc(label)}</text>
            ` : '';
            
            const arrowHit = `<circle class="conn-hit" cx="${fromX + 5}" cy="${endY}" r="15" fill="transparent" data-conn="${conn.id}" style="cursor:pointer;pointer-events:all"/>`;
            
            return `<g class="connection-group ${isConnSelected ? 'selected' : ''}" data-id="${conn.id}" data-conn="${conn.id}" style="cursor:pointer">
              <path class="conn-hit" d="${loopPath}" fill="none" stroke="transparent" stroke-width="20" data-conn="${conn.id}" style="cursor:pointer;pointer-events:stroke"/>
              ${arrowHit}
              <path d="${loopPath}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${dashArray}" style="pointer-events:none"/>
              <path d="${arrowPath}" fill="${isAsync ? 'none' : strokeColor}" stroke="${strokeColor}" stroke-width="1.5" style="pointer-events:none"/>
              ${labelEl}
            </g>`;
          }
          
          // Arrow direction
          const dir = toX > fromX ? 1 : -1;
          const arrowX = toX - dir * 3;
          
          // Arrow head
          let arrowPath;
          if (isAsync) {
            // Open arrow for async
            arrowPath = `M${arrowX - dir * aLen},${y - aWidth} L${arrowX},${y} L${arrowX - dir * aLen},${y + aWidth}`;
          } else {
            // Filled arrow
            arrowPath = `M${arrowX},${y} L${arrowX - dir * aLen},${y - aWidth} L${arrowX - dir * aLen},${y + aWidth} Z`;
          }
          
          // Label
          const midX = (fromX + toX) / 2;
          const labelEl = label ? `
            <rect x="${midX - label.length * 3.5 - 4}" y="${y - 18}" width="${label.length * 7 + 8}" height="14" fill="${COLORS.bg}" rx="2" data-conn="${conn.id}" style="cursor:pointer;pointer-events:fill"/>
            <text x="${midX}" y="${y - 8}" fill="${COLORS.fg}" font-size="11" font-family="system-ui, sans-serif" text-anchor="middle" data-conn="${conn.id}" style="cursor:pointer;pointer-events:painted">${esc(label)}</text>
          ` : '';
          
          // Hit area for arrow head (circle around arrow tip)
          const arrowHitX = toX - dir * 5;
          const arrowHit = `<circle class="conn-hit" cx="${arrowHitX}" cy="${y}" r="15" fill="transparent" data-conn="${conn.id}" style="cursor:pointer;pointer-events:all"/>`;
          return `<g class="connection-group ${isConnSelected ? 'selected' : ''}" data-id="${conn.id}" data-conn="${conn.id}" style="cursor:pointer">
            <line class="conn-hit" x1="${fromX}" y1="${y}" x2="${toX}" y2="${y}" stroke="transparent" stroke-width="20" data-conn="${conn.id}" style="cursor:pointer;pointer-events:stroke"/>
            ${arrowHit}
            <line x1="${fromX}" y1="${y}" x2="${arrowX}" y2="${y}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${dashArray}" class="connection" style="pointer-events:none"/>
            <path d="${arrowPath}" fill="${isAsync ? 'none' : strokeColor}" stroke="${strokeColor}" stroke-width="1.5" style="pointer-events:none"/>
            ${labelEl}
          </g>`;
        }
        
        // Smart routing - ignores stored sides, calculates optimal path
        const lineStyle = conn.lineStyle || 'rounded';
        const { points, endX, endY } = routeConnection(from, to, lineStyle);
        const [x1, y1] = [points[0].x, points[0].y];
        const [x2, y2] = [points[points.length-1].x, points[points.length-1].y];
        
        // Rounded corners for 'rounded' style
        const r = lineStyle === 'rounded' ? 12 : 0;
        let path, midX, midY, angle;
        
        if (lineStyle === 'rounded' && points.length >= 3) {
          path = `M${points[0].x},${points[0].y}`;
          for (let i = 1; i < points.length - 1; i++) {
            const prev = points[i - 1], curr = points[i], next = points[i + 1];
            const dx1 = curr.x - prev.x, dy1 = curr.y - prev.y;
            const dx2 = next.x - curr.x, dy2 = next.y - curr.y;
            const len1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            if (len1 > 0 && len2 > 0) {
              const rr = Math.min(r, len1/2, len2/2);
              const nx1 = dx1/len1, ny1 = dy1/len1;
              const nx2 = dx2/len2, ny2 = dy2/len2;
              const bx = curr.x - nx1 * rr, by = curr.y - ny1 * rr;
              const ax = curr.x + nx2 * rr, ay = curr.y + ny2 * rr;
              path += ` L${bx},${by} Q${curr.x},${curr.y} ${ax},${ay}`;
            } else {
              path += ` L${curr.x},${curr.y}`;
            }
          }
          path += ` L${points[points.length-1].x},${points[points.length-1].y}`;
        } else {
          path = points.map((p, i) => (i === 0 ? 'M' : 'L') + p.x + ',' + p.y).join(' ');
        }
        
        // Calculate midpoint along the path (middle of middle segment)
        if (points.length >= 3) {
          const midIdx = Math.floor((points.length - 1) / 2);
          const p1 = points[midIdx];
          const p2 = points[midIdx + 1];
          midX = (p1.x + p2.x) / 2;
          midY = (p1.y + p2.y) / 2;
        } else {
          midX = (x1 + x2) / 2;
          midY = (y1 + y2) / 2;
        }
        
        // Arrow pointing toward the node edge
        const lastPt = points[points.length - 1];
        const prevPt = points.length > 1 ? points[points.length - 2] : points[0];
        angle = Math.atan2(endY - prevPt.y, endX - prevPt.x);
        
        const aLen = 8, aWidth = 4;
        const tipGap = 3; // Small gap between arrow tip and node for premium look
        // Arrow tip near the endpoint with a small gap
        const tipX = endX - Math.cos(angle) * tipGap;
        const tipY = endY - Math.sin(angle) * tipGap;
        const baseX = tipX - Math.cos(angle) * aLen;
        const baseY = tipY - Math.sin(angle) * aLen;
        const px = Math.cos(angle + Math.PI/2) * aWidth;
        const py = Math.sin(angle + Math.PI/2) * aWidth;
        const arrow = `M${tipX},${tipY} L${baseX + px},${baseY + py} L${baseX - px},${baseY - py} Z`;
        
        // Label with background (no border, multi-line support)
        const label = conn.label || '';
        const isConnSelected = selectedConnId === conn.id;
        const strokeColor = isConnSelected ? COLORS.accent : COLORS.fg;
        const strokeWidth = isConnSelected ? 2.5 : 1.5;
        
        let labelEl = '';
        if (label) {
          // Word wrap for long labels (max ~15 chars per line)
          const maxChars = 15;
          const words = label.split(' ');
          const lines = [];
          let currentLine = '';
          
          words.forEach(word => {
            if ((currentLine + ' ' + word).trim().length <= maxChars) {
              currentLine = (currentLine + ' ' + word).trim();
            } else {
              if (currentLine) lines.push(currentLine);
              currentLine = word;
            }
          });
          if (currentLine) lines.push(currentLine);
          
          const lineHeight = 16;
          const padding = 8;
          const maxLineWidth = Math.max(...lines.map(l => l.length)) * 7;
          const boxWidth = maxLineWidth + padding * 2;
          const boxHeight = lines.length * lineHeight + padding;
          const boxY = midY - boxHeight / 2;
          
          const tspans = lines.map((line, i) => 
            `<tspan x="${midX}" dy="${i === 0 ? 0 : lineHeight}">${esc(line)}</tspan>`
          ).join('');
          
          labelEl = `
            <rect x="${midX - boxWidth/2}" y="${boxY}" width="${boxWidth}" height="${boxHeight}" rx="4" fill="${COLORS.bg}" stroke="none" data-conn="${conn.id}" style="cursor:pointer;pointer-events:fill"/>
            <text x="${midX}" y="${boxY + padding + 10}" fill="${COLORS.fg}" font-size="12" font-family="system-ui, sans-serif" text-anchor="middle" data-conn="${conn.id}" style="cursor:pointer;pointer-events:painted">${tspans}</text>
          `;
        }
        
        // Wider path for easier clicking
        const hitArea = `<path class="conn-hit" d="${path}" fill="none" stroke="transparent" stroke-width="20" data-conn="${conn.id}" style="cursor:pointer;pointer-events:stroke"/>`;
        // Arrow head hit area (circle around tip)
        const arrowHit = `<circle class="conn-hit" cx="${tipX}" cy="${tipY}" r="15" fill="transparent" data-conn="${conn.id}" style="cursor:pointer;pointer-events:all"/>`;
        
        const connDashArray = conn.strokeStyle === 'dashed' ? '5,3' : 'none';
        return `<g class="connection-group ${isConnSelected ? 'selected' : ''}" data-id="${conn.id}" data-conn="${conn.id}" style="cursor:pointer">${hitArea}${arrowHit}<path class="connection" d="${path}" fill="none" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${connDashArray}" style="pointer-events:none"/><path d="${arrow}" fill="${strokeColor}" style="pointer-events:none"/>${labelEl}</g>`;
      }).join('');
      
      // Nodes
      const sorted = [...nodes].sort((a, b) => (a.type === 'container' ? 0 : 1) - (b.type === 'container' ? 0 : 1));
      
      nodesGroup.innerHTML = sorted.map(node => {
        const isSelected = node.id === selectedId || selectedIds.includes(node.id);
        const strokeColor = node.outlineColor || COLORS.fg;
        
        const getTextColor = (bgColor) => {
          if (!bgColor || bgColor === 'transparent') return COLORS.fg;
          const hex = bgColor.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.5 ? '#1a1b26' : '#ffffff';
        };
        const textColor = node.color ? getTextColor(node.color) : COLORS.fg;
        
        const getFill = (node, defaultStyle) => {
          const style = node.fillStyle || defaultStyle;
          let fill;
          if (node.color) {
            if (style === 'outline') fill = 'transparent';
            else if (style === 'infill') fill = node.type === 'container' ? node.color + '25' : node.color;
            else if (style === 'stripe') fill = `url(#stripe-${node.id})`;
            else if (style === 'grid') fill = `url(#grid-${node.id})`;
          } else {
            if (style === 'outline') fill = 'transparent';
            else if (style === 'infill') fill = COLORS.bg2;
            else if (style === 'stripe') fill = 'url(#stripe)';
            else if (style === 'grid') fill = 'url(#grid-fill)';
          }
          return { fill, style };
        };
        
        const getCustomPattern = (node) => {
          const style = node.fillStyle || (node.type === 'container' ? 'outline' : 'infill');
          if (style === 'stripe' && node.color) {
            return `<defs><pattern id="stripe-${node.id}" width="8" height="8" patternUnits="userSpaceOnUse" patternTransform="rotate(-45)">
              <line x1="0" y1="0" x2="0" y2="8" stroke="${node.color}" stroke-width="2" opacity="0.4"/>
            </pattern></defs>`;
          }
          if (style === 'grid' && node.color) {
            return `<defs><pattern id="grid-${node.id}" width="10" height="10" patternUnits="userSpaceOnUse">
              <circle cx="5" cy="5" r="0.5" fill="${node.color}" opacity="0.6"/>
            </pattern></defs>`;
          }
          return '';
        };
        
        let shape;
        if (node.type === 'container') {
          const { fill } = getFill(node, 'outline');
          const customPattern = getCustomPattern(node);
          shape = `${customPattern}<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="8" 
            fill="${fill}" stroke="none" class="container-fill"/>
            <rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="8" 
            fill="none" stroke="${strokeColor}" stroke-width="1.5" class="node-border"/>
            <text x="${node.x + 12}" y="${node.y + 22}" fill="${node.color || COLORS.fg}" font-size="13" font-weight="600" font-family="system-ui, sans-serif" style="pointer-events:none">${esc(node.label)}</text>`;
        } else if (node.type === 'diamond') {
          const { fill, style } = getFill(node, 'infill');
          const customPattern = getCustomPattern(node);
          const cx = node.x + node.width / 2, cy = node.y + node.height / 2;
          // For outline, stripe, grid - use light text; for solid infill - use contrast text
          const txtColor = (style === 'outline' || style === 'stripe' || style === 'grid') ? (node.outlineColor || COLORS.fg) : textColor;
          shape = `${customPattern}<polygon points="${cx},${node.y} ${node.x + node.width},${cy} ${cx},${node.y + node.height} ${node.x},${cy}" 
            fill="${fill}" stroke="${strokeColor}" stroke-width="1.5" class="node-border"/>
            <text x="${cx}" y="${cy + 4}" fill="${txtColor}" font-size="12" font-family="system-ui, sans-serif" text-anchor="middle">${esc(node.label)}</text>`;
        } else if (node.type === 'circle') {
          const { fill, style } = getFill(node, 'infill');
          const customPattern = getCustomPattern(node);
          const cx = node.x + node.width / 2, cy = node.y + node.height / 2;
          const txtColor = (style === 'outline' || style === 'stripe' || style === 'grid') ? (node.outlineColor || COLORS.fg) : textColor;
          shape = `${customPattern}<circle cx="${cx}" cy="${cy}" r="${node.width / 2}" 
            fill="${fill}" stroke="${strokeColor}" stroke-width="1.5" class="node-border"/>
            <text x="${cx}" y="${cy + 4}" fill="${txtColor}" font-size="12" font-family="system-ui, sans-serif" text-anchor="middle">${esc(node.label)}</text>`;
        } else if (node.type === 'text') {
          // Text node - just text, no shape border (unless selected)
          const txtColor = node.color || COLORS.fg;
          shape = `<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" 
            fill="transparent" stroke="${isSelected ? COLORS.accent : 'transparent'}" stroke-width="1" stroke-dasharray="${isSelected ? '4' : '0'}" class="node-border"/>
            <text x="${node.x + node.width/2}" y="${node.y + node.height/2 + 5}" fill="${txtColor}" font-size="14" font-family="system-ui, sans-serif" text-anchor="middle" style="pointer-events:none">${esc(node.label)}</text>`;
        } else if (node.type === 'line') {
          // Standalone arrow/line shape
          const x1 = node.x;
          const y1 = node.y;
          const x2 = node.x + node.width;
          const y2 = node.y + node.height;
          // Use outlineColor for line color (not fill color)
          const lineColor = node.outlineColor || COLORS.fg;
          const lineWidth = isSelected ? 2.5 : 1.5;
          const isDashed = node.lineStyle === 'dashed';
          const dashArray = isDashed ? '6,4' : 'none';
          
          // Calculate arrow head
          const angle = Math.atan2(y2 - y1, x2 - x1);
          const aLen = 10, aWidth = 5;
          const tipX = x2;
          const tipY = y2;
          const baseX = tipX - Math.cos(angle) * aLen;
          const baseY = tipY - Math.sin(angle) * aLen;
          const px = Math.cos(angle + Math.PI/2) * aWidth;
          const py = Math.sin(angle + Math.PI/2) * aWidth;
          const arrow = `M${tipX},${tipY} L${baseX + px},${baseY + py} L${baseX - px},${baseY - py} Z`;
          
          // Hit area for easier selection
          const hitArea = `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="transparent" stroke-width="15" stroke-linecap="round"/>`;
          
          // Selection handles at endpoints
          const handles = isSelected ? `
            <circle cx="${x1}" cy="${y1}" r="5" fill="${COLORS.accent}" class="line-handle start-handle" style="cursor:move"/>
            <circle cx="${x2}" cy="${y2}" r="5" fill="${COLORS.accent}" class="line-handle end-handle" style="cursor:move"/>
          ` : '';
          
          // Optional label in middle
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          const labelEl = node.label && node.label !== 'Arrow' ? `
            <rect x="${midX - node.label.length * 3.5 - 4}" y="${midY - 10}" width="${node.label.length * 7 + 8}" height="16" fill="${COLORS.bg}" rx="2"/>
            <text x="${midX}" y="${midY + 3}" fill="${COLORS.fg}" font-size="11" font-family="system-ui, sans-serif" text-anchor="middle">${esc(node.label)}</text>
          ` : '';
          
          const displayColor = isSelected ? COLORS.accent : lineColor;
          shape = `${hitArea}
            <line x1="${x1}" y1="${y1}" x2="${x2 - Math.cos(angle) * 3}" y2="${y2 - Math.sin(angle) * 3}" 
              stroke="${displayColor}" stroke-width="${lineWidth}" stroke-linecap="round" stroke-dasharray="${dashArray}" class="node-border"/>
            <path d="${arrow}" fill="${displayColor}"/>
            ${labelEl}
            ${handles}`;
        } else if (node.isClass) {
          // UML Class box with header, properties, methods
          const headerH = 28;
          const props = node.properties || [];
          const methods = node.methods || [];
          const lineH = 16;
          const propsH = Math.max(20, props.length * lineH + 8);
          const methodsH = Math.max(20, methods.length * lineH + 8);
          const totalH = headerH + propsH + methodsH;
          
          // Update node height if needed
          if (node.height < totalH) node.height = totalH;
          
          const propsY = node.y + headerH;
          const methodsY = propsY + propsH;
          
          let propsText = props.map((p, i) => 
            `<text x="${node.x + 8}" y="${propsY + 14 + i * lineH}" fill="${COLORS.fg}" font-size="11" font-family="monospace">${esc(p)}</text>`
          ).join('');
          
          let methodsText = methods.map((m, i) => 
            `<text x="${node.x + 8}" y="${methodsY + 14 + i * lineH}" fill="${COLORS.fg}" font-size="11" font-family="monospace">${esc(m)}</text>`
          ).join('');
          
          shape = `
            <rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="4" 
              fill="${COLORS.bg2}" stroke="${strokeColor}" stroke-width="1.5" class="node-border"/>
            <rect x="${node.x}" y="${node.y}" width="${node.width}" height="${headerH}" rx="4" 
              fill="${node.color || COLORS.accent}" stroke="none"/>
            <rect x="${node.x}" y="${node.y + headerH - 4}" width="${node.width}" height="4" 
              fill="${node.color || COLORS.accent}" stroke="none"/>
            <text x="${node.x + node.width/2}" y="${node.y + 18}" fill="#1a1b26" font-size="12" font-weight="600" font-family="system-ui, sans-serif" text-anchor="middle">${esc(node.label)}</text>
            <line x1="${node.x}" y1="${propsY}" x2="${node.x + node.width}" y2="${propsY}" stroke="${COLORS.border}" stroke-width="1"/>
            ${propsText}
            <line x1="${node.x}" y1="${methodsY}" x2="${node.x + node.width}" y2="${methodsY}" stroke="${COLORS.border}" stroke-width="1"/>
            ${methodsText}
          `;
        } else {
          const { fill, style } = getFill(node, 'infill');
          const customPattern = getCustomPattern(node);
          const rx = node.type === 'pill' ? node.height / 2 : 6;
          // For outline, stripe, grid - use light text; for solid infill - use contrast text
          const txtColor = (style === 'outline' || style === 'stripe' || style === 'grid') ? (node.outlineColor || COLORS.fg) : textColor;
          shape = `${customPattern}<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" rx="${rx}" 
            fill="${fill}" stroke="${strokeColor}" stroke-width="1.5" class="node-border"/>
            <text x="${node.x + node.width/2}" y="${node.y + node.height/2 + 4}" fill="${txtColor}" font-size="12" font-family="system-ui, sans-serif" text-anchor="middle">${esc(node.label)}</text>`;
        }
        
        // Add lifeline for sequence participants with clickable connection zones
        let lifeline = '';
        const showLifeline = node.isParticipant || node.hasLifeline;
        if (showLifeline) {
          const lifeX = node.x + node.width/2;
          const lifeY1 = node.y + node.height;
          const lifeY2 = node.y + node.height + lifelineHeight;
          
          // The dashed lifeline
          lifeline = `
            <line x1="${lifeX}" y1="${lifeY1}" x2="${lifeX}" y2="${lifeY2}" 
                  stroke="${COLORS.border}" stroke-width="1.5" stroke-dasharray="6,4"/>
          `;
          
          // Add connection points along the lifeline (every 35px)
          // Start points 30px below the node to avoid overlap
          const zoneSpacing = 35;
          for (let y = lifeY1 + 30; y < lifeY2 - 20; y += zoneSpacing) {
            lifeline += `
              <circle class="lifeline-connector" cx="${lifeX}" cy="${y}" r="3"
                    fill="${COLORS.bg2}" stroke="${COLORS.fg}" stroke-width="1" style="cursor:crosshair" 
                    data-node="${node.id}" data-lifeline-y="${y}" data-side="bottom"/>
            `;
          }
        }
        
        // Don't render connectors for line/arrow shapes or nodes with lifelines
        const hasLifelineActive = node.isParticipant || node.hasLifeline;
        const connectors = (node.type === 'line' || hasLifelineActive) ? '' : renderConnectors(node);
        // Don't render resize handle for line shapes - they have endpoint handles
        const resizeHandle = (isSelected && node.type !== 'line') ? 
          `<rect class="resize-handle" x="${node.x + node.width - 8}" y="${node.y + node.height - 8}" width="8" height="8" fill="${COLORS.accent}" rx="2"/>` : '';
        
        return `<g class="node ${isSelected ? 'selected' : ''}" data-id="${node.id}">
          ${lifeline}
          ${shape}
          ${connectors}
          ${resizeHandle}
        </g>`;
      }).join('');
      
      // Bind events
      document.querySelectorAll('.node').forEach(el => {
        el.addEventListener('mousedown', onNodeMouseDown);
        el.addEventListener('dblclick', onNodeDblClick);
      });
      document.querySelectorAll('.connector').forEach(el => el.addEventListener('mousedown', onConnectorMouseDown));
      document.querySelectorAll('.lifeline-connector').forEach(el => el.addEventListener('mousedown', onLifelineConnectorMouseDown));
      document.querySelectorAll('.resize-handle').forEach(el => el.addEventListener('mousedown', onResizeMouseDown));
      document.querySelectorAll('.line-handle').forEach(el => el.addEventListener('mousedown', onLineHandleMouseDown));
      document.querySelectorAll('.conn-hit').forEach(el => {
        el.addEventListener('mousedown', onConnectionMouseDown);
      });
    }
    
    function renderConnectors(node) {
      const connectors = [];
      const offsets = [0.25, 0.5, 0.75];
      ['top', 'bottom', 'left', 'right'].forEach(side => {
        offsets.forEach((off, i) => {
          let x, y;
          if (side === 'top' || side === 'bottom') {
            x = node.x + node.width * off;
            y = side === 'top' ? node.y : node.y + node.height;
          } else {
            x = side === 'left' ? node.x : node.x + node.width;
            y = node.y + node.height * off;
          }
          connectors.push({ x, y, side, idx: i });
        });
      });
      return connectors.map(c => 
        `<circle class="connector" cx="${c.x}" cy="${c.y}" r="3" fill="${COLORS.bg2}" stroke="${COLORS.fg}" stroke-width="1" data-node="${node.id}" data-side="${c.side}" data-idx="${c.idx}"/>`
      ).join('');
    }
    
    function getConnectorPos(node, side, idx = 1) {
      const offsets = [0.25, 0.5, 0.75];
      const off = offsets[idx] || 0.5;
      switch(side) {
        case 'top': return [node.x + node.width * off, node.y];
        case 'bottom': return [node.x + node.width * off, node.y + node.height];
        case 'left': return [node.x, node.y + node.height * off];
        case 'right': return [node.x + node.width, node.y + node.height * off];
      }
    }
    
    function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    
    // Selection
    function selectNode(id) {
      selectedId = id;
      selectedConnId = null;
      hideConnToolbar();
      const node = nodes.find(n => n.id === id);
      if (node) {
        toolbarLabel.value = node.label;
        updateToolbarColors(node);
        updateShapeButton(node);
        positionToolbar(node);
        floatingToolbar.classList.remove('hidden');
        closeShapeDropdown();
        closeFillDropdown();
        closeFillColorPalette();
        closeOutlineColorPalette();
        closeLineStyleDropdown();
        
        // Show/hide controls based on node type
        const isLine = node.type === 'line';
        document.getElementById('fillStyleGroup').style.display = isLine ? 'none' : 'inline-block';
        document.getElementById('fillColorGroup').style.display = isLine ? 'none' : 'inline-block';
        document.getElementById('lineStyleGroup').style.display = isLine ? 'inline-block' : 'none';
        document.getElementById('lifelineToggle').style.display = isLine ? 'none' : 'flex';
        
        // Update line style button
        if (isLine) {
          updateLineStyleButton(node);
        }
        
        // Update lifeline button state
        updateLifelineButton(node);
      } else {
        floatingToolbar.classList.add('hidden');
      }
      render();
    }
    
    function deselectAll() {
      selectedId = null;
      selectedIds = [];
      selectedConnId = null;
      floatingToolbar.classList.add('hidden');
      hideConnToolbar();
      render();
    }
    
    function positionToolbar(node) {
      const canvasContainer = document.getElementById('canvasContainer');
      const containerRect = canvasContainer.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = canvasRect.width / viewBox.w;
      const nodeScreenX = (node.x - viewBox.x) * scaleX;
      const nodeScreenY = (node.y - viewBox.y) * scaleX;
      const nodeScreenW = node.width * scaleX;
      const toolbarW = floatingToolbar.offsetWidth || 280;
      let left = nodeScreenX + (nodeScreenW - toolbarW) / 2;
      let top = nodeScreenY - 60;
      left = Math.max(10, Math.min(left, containerRect.width - toolbarW - 10));
      top = Math.max(10, top);
      floatingToolbar.style.left = left + 'px';
      floatingToolbar.style.top = top + 'px';
    }
    
    function deleteSelected() {
      // Delete selected connection
      if (selectedConnId) {
        deleteSelectedConn();
        return;
      }
      
      // Delete selected nodes
      const toDelete = selectedIds.length > 0 ? selectedIds : (selectedId ? [selectedId] : []);
      if (toDelete.length > 0) {
        nodes = nodes.filter(n => !toDelete.includes(n.id));
        connections = connections.filter(c => !toDelete.includes(c.from) && !toDelete.includes(c.to));
        deselectAll();
        saveState();
        render();
      }
    }
    
    // Connection toolbar functions
    const connToolbar = document.getElementById('connToolbar');
    const connLabelInput = document.getElementById('connLabel');
    
    function showConnToolbar(conn) {
      const fromNode = nodes.find(n => n.id === conn.from);
      const toNode = nodes.find(n => n.id === conn.to);
      if (!fromNode || !toNode) return;
      
      let midX, midY;
      
      if (conn.isSequenceMessage) {
        // For sequence messages, use the actual message Y position
        const fromX = fromNode.x + fromNode.width / 2;
        const toX = toNode.x + toNode.width / 2;
        midX = (fromX + toX) / 2;
        midY = conn.messageY || 150;
      } else {
        // Regular connection - use node centers
        midX = (fromNode.x + fromNode.width/2 + toNode.x + toNode.width/2) / 2;
        midY = (fromNode.y + fromNode.height/2 + toNode.y + toNode.height/2) / 2;
      }
      
      // Convert to screen coordinates
      const canvasContainer = document.getElementById('canvasContainer');
      const containerRect = canvasContainer.getBoundingClientRect();
      const scaleX = containerRect.width / viewBox.w;
      const screenX = (midX - viewBox.x) * scaleX;
      const screenY = (midY - viewBox.y) * scaleX - 50;
      
      connLabelInput.value = conn.label || '';
      document.getElementById('connColorBtn').style.borderColor = conn.color || '#a9b1d6';
      // For sequence messages, detect default from arrow syntax
      const defaultStroke = conn.isSequenceMessage && conn.arrow?.includes('--') ? 'dashed' : 'solid';
      updateConnLineStyleBtns(conn.strokeStyle || defaultStroke);
      
      // Position relative to canvas container
      connToolbar.style.left = `${Math.max(100, Math.min(screenX, containerRect.width - 150))}px`;
      connToolbar.style.top = `${Math.max(10, screenY)}px`;
      connToolbar.style.transform = 'translateX(-50%)';
      connToolbar.classList.remove('hidden');
    }
    
    function hideConnToolbar() {
      connToolbar.classList.add('hidden');
      document.getElementById('connColorPalette').classList.add('hidden');
    }
    
    function deselectConn() {
      selectedConnId = null;
      hideConnToolbar();
      render();
    }
    
    function deleteSelectedConn() {
      if (selectedConnId) {
        connections = connections.filter(c => c.id !== selectedConnId);
        selectedConnId = null;
        hideConnToolbar();
        saveState();
        render();
      }
    }
    
    function toggleConnColorPalette() {
      document.getElementById('connColorPalette').classList.toggle('hidden');
    }
    
    function closeConnColorPalette() {
      document.getElementById('connColorPalette').classList.add('hidden');
    }
    
    function setConnColor(color) {
      const conn = connections.find(c => c.id === selectedConnId);
      if (conn) {
        conn.color = color;
        document.getElementById('connColorBtn').style.borderColor = color || '#a9b1d6';
        saveState();
        render();
      }
    }
    
    function setConnLineStyle(style) {
      const conn = connections.find(c => c.id === selectedConnId);
      if (conn) {
        conn.strokeStyle = style;
        updateConnLineStyleBtns(style);
        saveState();
        render();
      }
    }
    
    function updateConnLineStyleBtns(style) {
      const solidBtn = document.getElementById('connSolidBtn');
      const dottedBtn = document.getElementById('connDottedBtn');
      solidBtn.style.borderColor = style === 'dashed' ? 'transparent' : '#7aa2f7';
      dottedBtn.style.borderColor = style === 'dashed' ? '#7aa2f7' : 'transparent';
    }
    
    // Update connection label on input
    connLabelInput.addEventListener('input', () => {
      const conn = connections.find(c => c.id === selectedConnId);
      if (conn) {
        conn.label = connLabelInput.value;
        render();
      }
    });
    
    connLabelInput.addEventListener('change', () => {
      saveState();
    });
    
    // Node properties
    function setOutlineColor(color) {
      const node = nodes.find(n => n.id === selectedId);
      if (node) { node.outlineColor = color; updateToolbarColors(node); saveState(); render(); }
    }
    
    function setNodeColor(color) {
      const node = nodes.find(n => n.id === selectedId);
      if (node) {
        node.color = color;
        if (color && node.fillStyle === 'outline') node.fillStyle = 'infill';
        updateToolbarColors(node);
        saveState();
        render();
      }
    }
    
    function setFillStyle(style) {
      const node = nodes.find(n => n.id === selectedId);
      if (node) { node.fillStyle = style; saveState(); render(); }
    }
    
    function updateToolbarColors(node) {
      document.getElementById('fillColorBtn').style.background = node.color || '#24283b';
      document.getElementById('outlineColorBtn').style.borderColor = node.outlineColor || '#a9b1d6';
      const style = node.fillStyle || (node.type === 'container' ? 'outline' : 'infill');
      const icons = { outline: '○', infill: '●', stripe: '▤', grid: '▦' };
      document.getElementById('fillStyleBtn').textContent = icons[style] || '●';
    }
    
    function toggleShapeDropdown() { document.getElementById('shapeDropdown').classList.toggle('hidden'); closeOtherPalettes('shape'); }
    function closeShapeDropdown() { document.getElementById('shapeDropdown').classList.add('hidden'); }
    
    function changeShape(newType) {
      const node = nodes.find(n => n.id === selectedId);
      if (node && node.type !== newType) {
        node.type = newType;
        // Adjust size for certain shapes
        if (newType === 'circle') {
          const size = Math.max(node.width, node.height);
          node.width = size;
          node.height = size;
        }
        if (newType === 'container' && node.width < 200) {
          node.width = 280;
          node.height = 180;
        }
        updateShapeButton(node);
        saveState();
        render();
        selectNode(node.id);
      }
    }
    
    function updateShapeButton(node) {
      const icons = {
        rect: '<rect x="3" y="3" width="18" height="18" rx="2"/>',
        pill: '<rect x="2" y="6" width="20" height="12" rx="6"/>',
        diamond: '<polygon points="12,2 22,12 12,22 2,12"/>',
        circle: '<circle cx="12" cy="12" r="10"/>',
        container: '<rect x="2" y="2" width="20" height="20" rx="2" stroke-dasharray="4"/>',
        text: '<path d="M4 7V4h16v3M9 20h6M12 4v16"/>',
        line: '<line x1="5" y1="19" x2="19" y2="5"/><polyline points="12 5 19 5 19 12"/>'
      };
      const btn = document.getElementById('shapeBtn');
      if (btn) {
        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">${icons[node.type] || icons.rect}</svg>`;
      }
    }
    
    function closeOtherPalettes(except) {
      if (except !== 'shape') closeShapeDropdown();
      if (except !== 'fill') closeFillDropdown();
      if (except !== 'fillColor') closeFillColorPalette();
      if (except !== 'outlineColor') closeOutlineColorPalette();
      if (except !== 'lineStyle') closeLineStyleDropdown();
    }
    
    function toggleFillDropdown() { document.getElementById('fillDropdown').classList.toggle('hidden'); closeOtherPalettes('fill'); }
    function closeFillDropdown() { document.getElementById('fillDropdown').classList.add('hidden'); }
    function toggleFillColorPalette() { document.getElementById('fillColorPalette').classList.toggle('hidden'); closeOtherPalettes('fillColor'); }
    function closeFillColorPalette() { document.getElementById('fillColorPalette').classList.add('hidden'); }
    function toggleOutlineColorPalette() { document.getElementById('outlineColorPalette').classList.toggle('hidden'); closeOtherPalettes('outlineColor'); }
    function closeOutlineColorPalette() { document.getElementById('outlineColorPalette').classList.add('hidden'); }
    
    // Line style functions (for arrow/line nodes)
    function toggleLineStyleDropdown() { 
      document.getElementById('lineStyleDropdown').classList.toggle('hidden'); 
      closeOtherPalettes('lineStyle'); 
    }
    function closeLineStyleDropdown() { 
      const dd = document.getElementById('lineStyleDropdown');
      if (dd) dd.classList.add('hidden'); 
    }
    function setLineStyle(style) {
      const node = nodes.find(n => n.id === selectedId);
      if (node && node.type === 'line') {
        node.lineStyle = style;
        updateLineStyleButton(node);
        saveState();
        render();
      }
    }
    function updateLineStyleButton(node) {
      const btn = document.getElementById('lineStyleBtn');
      if (!btn) return;
      const isDashed = node.lineStyle === 'dashed';
      btn.innerHTML = isDashed ? 
        `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="3,2" style="width:14px;height:14px"><line x1="4" y1="12" x2="20" y2="12"/></svg>` :
        `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px"><line x1="4" y1="12" x2="20" y2="12"/></svg>`;
    }
    
    // Lifeline toggle (for sequence diagrams)
    function toggleLifeline() {
      const node = nodes.find(n => n.id === selectedId);
      if (!node) return;
      node.hasLifeline = !node.hasLifeline;
      updateLifelineButton(node);
      saveState();
      render();
    }
    
    function updateLifelineButton(node) {
      const btn = document.getElementById('lifelineToggle');
      if (!btn) return;
      if (node.hasLifeline) {
        btn.style.background = '#7aa2f7';
        btn.style.color = '#1a1b26';
        btn.style.borderColor = '#7aa2f7';
      } else {
        btn.style.background = '#1a1b26';
        btn.style.color = '#a9b1d6';
        btn.style.borderColor = '#414868';
      }
    }
    
    function clearCanvas() {
      if (confirm('Clear entire canvas?')) {
        nodes = [];
        connections = [];
        deselectAll();
        saveState();
        render();
      }
    }
    
    // Smart auto-arrange based on diagram type
    function arrangeDiagram() {
      if (nodes.length === 0) return;
      
      // Detect diagram type
      const hasLifelines = nodes.some(n => n.hasLifeline || n.isParticipant);
      const hasClasses = nodes.some(n => n.isClass);
      const hasSequenceMessages = connections.some(c => c.isSequenceMessage);
      
      if (hasLifelines || hasSequenceMessages) {
        arrangeSequence();
      } else if (hasClasses) {
        arrangeClass();
      } else {
        arrangeFlowchart();
      }
      
      saveState();
      render();
      
      // Center view on arranged content
      const bounds = getContentBounds();
      if (bounds) {
        const contentWidth = bounds.maxX - bounds.minX;
        const contentHeight = bounds.maxY - bounds.minY;
        // Center the content in the viewport
        viewBox.x = bounds.minX - (viewBox.w - contentWidth) / 2;
        viewBox.y = bounds.minY - (viewBox.h - contentHeight) / 2;
        updateViewBox();
      }
    }
    
    // Arrange sequence diagram - horizontal alignment, even spacing
    function arrangeSequence() {
      const participants = nodes.filter(n => n.hasLifeline || n.isParticipant);
      const otherNodes = nodes.filter(n => !n.hasLifeline && !n.isParticipant);
      
      if (participants.length === 0) return;
      
      // Sort participants by current X position to preserve order
      participants.sort((a, b) => a.x - b.x);
      
      // Align all participants at same Y, distribute X evenly
      const startX = 100;
      const startY = 100;
      const spacingX = 150;
      
      participants.forEach((node, i) => {
        node.x = startX + i * spacingX;
        node.y = startY;
      });
      
      // Re-calculate sequence message Y positions to be evenly spaced below participants
      const seqMessages = connections.filter(c => c.isSequenceMessage);
      if (seqMessages.length > 0) {
        // Sort by current messageY to preserve order
        seqMessages.sort((a, b) => (a.messageY || 0) - (b.messageY || 0));
        
        const maxBottom = Math.max(...participants.map(n => n.y + n.height));
        const messageStartY = maxBottom + 40;
        const messageSpacing = 50;
        
        seqMessages.forEach((msg, i) => {
          msg.messageY = messageStartY + i * messageSpacing;
        });
      }
      
      // Place other nodes below the sequence area
      if (otherNodes.length > 0) {
        const seqBottom = seqMessages.length > 0 
          ? Math.max(...seqMessages.map(m => m.messageY || 0)) + 80
          : startY + 300;
        const cols = Math.ceil(Math.sqrt(otherNodes.length));
        otherNodes.forEach((node, i) => {
          node.x = startX + (i % cols) * 150;
          node.y = seqBottom + 50 + Math.floor(i / cols) * 80;
        });
      }
    }
    
    // Arrange class diagram - grid with proper spacing
    function arrangeClass() {
      const classes = nodes.filter(n => n.isClass);
      const otherNodes = nodes.filter(n => !n.isClass);
      
      const startX = 100;
      const startY = 100;
      const spacingX = 220;
      const spacingY = 180;
      const cols = Math.max(2, Math.ceil(Math.sqrt(classes.length)));
      
      classes.forEach((node, i) => {
        node.x = startX + (i % cols) * spacingX;
        node.y = startY + Math.floor(i / cols) * spacingY;
      });
      
      // Place other nodes to the right
      if (otherNodes.length > 0) {
        const classRight = classes.length > 0 
          ? Math.max(...classes.map(n => n.x + n.width)) + 100
          : startX;
        otherNodes.forEach((node, i) => {
          node.x = classRight + (i % 2) * 150;
          node.y = startY + Math.floor(i / 2) * 80;
        });
      }
    }
    
    // Arrange flowchart - layered layout based on connections
    function arrangeFlowchart() {
      // Skip line/arrow shapes - they don't need arranging
      const flowNodes = nodes.filter(n => n.type !== 'line');
      if (flowNodes.length === 0) return;
      
      // Build adjacency map
      const outgoing = {};
      const incoming = {};
      flowNodes.forEach(n => {
        outgoing[n.id] = [];
        incoming[n.id] = [];
      });
      
      connections.filter(c => !c.isSequenceMessage).forEach(c => {
        if (outgoing[c.from] && incoming[c.to]) {
          outgoing[c.from].push(c.to);
          incoming[c.to].push(c.from);
        }
      });
      
      // Find root nodes (no incoming connections)
      let roots = flowNodes.filter(n => incoming[n.id].length === 0);
      if (roots.length === 0) roots = [flowNodes[0]]; // Fallback: use first node
      
      // BFS to assign layers
      const layers = {};
      const visited = new Set();
      let queue = roots.map(n => ({ id: n.id, layer: 0 }));
      
      while (queue.length > 0) {
        const { id, layer } = queue.shift();
        if (visited.has(id)) continue;
        visited.add(id);
        
        if (!layers[layer]) layers[layer] = [];
        layers[layer].push(id);
        
        outgoing[id].forEach(targetId => {
          if (!visited.has(targetId)) {
            queue.push({ id: targetId, layer: layer + 1 });
          }
        });
      }
      
      // Add any unvisited nodes to layer 0
      flowNodes.forEach(n => {
        if (!visited.has(n.id)) {
          if (!layers[0]) layers[0] = [];
          layers[0].push(n.id);
        }
      });
      
      // Position nodes by layer with better spacing
      const startX = 100;
      const startY = 100;
      const layerSpacingY = 110;
      const nodeSpacingX = 170;
      
      Object.keys(layers).sort((a, b) => a - b).forEach(layerNum => {
        const layerNodes = layers[layerNum];
        const layerWidth = layerNodes.length * nodeSpacingX;
        const layerStartX = startX + (Math.max(...Object.values(layers).map(l => l.length)) * nodeSpacingX - layerWidth) / 2;
        
        layerNodes.forEach((nodeId, i) => {
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            node.x = layerStartX + i * nodeSpacingX;
            node.y = startY + parseInt(layerNum) * layerSpacingY;
          }
        });
      });
      
      // Position line/arrow shapes at the bottom
      const lineNodes = nodes.filter(n => n.type === 'line');
      if (lineNodes.length > 0) {
        const flowBottom = Math.max(...flowNodes.map(n => n.y + n.height)) + 50;
        lineNodes.forEach((node, i) => {
          node.x = startX + i * 150;
          node.y = flowBottom;
        });
      }
    }
    
    function setGlobalLineStyle(style) {
      globalLineStyle = style;
      document.querySelectorAll('[data-line]').forEach(btn => btn.classList.toggle('active', btn.dataset.line === style));
      connections.forEach(c => c.lineStyle = style);
      closeDropdowns();
      if (connections.length > 0) { saveState(); render(); }
    }
    
    // Find best connector side for a point relative to a node
    function getBestConnectorSide(node, px, py) {
      const cx = node.x + node.width / 2;
      const cy = node.y + node.height / 2;
      const dx = px - cx;
      const dy = py - cy;
      
      if (Math.abs(dx) > Math.abs(dy)) {
        return dx > 0 ? 'right' : 'left';
      } else {
        return dy > 0 ? 'bottom' : 'top';
      }
    }
    
    // Event handlers
    function onNodeMouseDown(e) {
      if (e.target.classList.contains('connector') || e.target.classList.contains('resize-handle') || e.target.classList.contains('lifeline-connector')) return;
      
      // Clicking on a node always switches to select mode and selects it
      if (currentTool !== 'select') {
        setTool('select');
      }
      
      const id = e.currentTarget.dataset.id;
      let node = nodes.find(n => n.id === id);
      if (!node) return;
      
      // Alt + drag = duplicate
      if (e.altKey) {
        const newNode = { ...node, id: generateId() };
        nodes.push(newNode);
        node = newNode;
        saveState();
        render();
      }
      
      selectNode(node.id);
      const pos = screenToCanvas(e.clientX, e.clientY);
      dragging = { node, offsetX: pos.x - node.x, offsetY: pos.y - node.y };
      e.preventDefault();
    }
    
    function onNodeDblClick(e) {
      if (e.target.classList.contains('connector') || e.target.classList.contains('resize-handle')) return;
      const id = e.currentTarget.dataset.id;
      e.stopPropagation();
      e.preventDefault();
      dragging = null;
      setTool('select');
      selectNode(id);
      setTimeout(() => {
        const input = document.getElementById('toolbarLabel');
        if (input) { input.focus(); input.select(); }
      }, 100);
    }
    
    function onConnectionMouseDown(e) {
      const connId = e.target.dataset.conn || e.currentTarget.dataset.conn;
      if (!connId) return;
      
      // Select connection and show toolbar (toolbar has label input)
      selectedConnId = connId;
      selectedId = null;
      selectedIds = [];
      floatingToolbar.classList.add('hidden');
      render();
      const conn = connections.find(c => c.id === connId);
      if (conn) showConnToolbar(conn);
      
      e.stopPropagation();
      e.preventDefault();
    }
    
    function onConnectorMouseDown(e) {
      connecting = { 
        from: e.target.dataset.node, 
        fromSide: e.target.dataset.side,
        fromIdx: parseInt(e.target.dataset.idx) || 1
      };
      showTempLine();
      canvas.classList.add('show-connectors');
      e.preventDefault();
      e.stopPropagation();
    }
    
    function onLifelineConnectorMouseDown(e) {
      const nodeId = e.target.dataset.node;
      const lifelineY = parseFloat(e.target.dataset.lifelineY);
      connecting = { 
        from: nodeId, 
        fromSide: 'bottom',
        fromIdx: 1,
        isLifeline: true,
        lifelineY: lifelineY
      };
      showTempLine();
      canvas.classList.add('show-connectors');
      e.preventDefault();
      e.stopPropagation();
    }
    
    let lineResizing = null;
    function onLineHandleMouseDown(e) {
      const nodeEl = e.target.closest('.node');
      if (!nodeEl) return;
      const nodeId = nodeEl.dataset.id;
      const node = nodes.find(n => n.id === nodeId);
      if (!node || node.type !== 'line') return;
      
      const isStart = e.target.classList.contains('start-handle');
      lineResizing = { 
        node, 
        isStart,
        origX: node.x,
        origY: node.y,
        origW: node.width,
        origH: node.height
      };
      e.preventDefault();
      e.stopPropagation();
    }
    
    let resizing = null;
    function onResizeMouseDown(e) {
      const node = nodes.find(n => n.id === selectedId);
      if (node) {
        resizing = { node, startW: node.width, startH: node.height, startX: e.clientX, startY: e.clientY };
      }
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Canvas events
    canvas.addEventListener('mousedown', (e) => {
      if (e.target.closest('.node') || e.target.classList.contains('connector')) return;
      
      const pos = screenToCanvas(e.clientX, e.clientY);
      
      // Shift+drag or middle mouse = pan
      if (e.shiftKey || e.button === 1) {
        panning = true;
        panStart = { x: e.clientX, y: e.clientY };
        canvas.style.cursor = 'grabbing';
        return;
      }
      
      // Shape drawing mode
      if (SHAPE_TOOLS.includes(currentTool)) {
        drawing = { startX: pos.x, startY: pos.y, type: currentTool };
        drawPreview.style.display = 'block';
        drawPreview.setAttribute('x', pos.x);
        drawPreview.setAttribute('y', pos.y);
        drawPreview.setAttribute('width', 0);
        drawPreview.setAttribute('height', 0);
        return;
      }
      
      // Select mode - marquee selection
      if (currentTool === 'select') {
        deselectAll();
        selecting = { startX: pos.x, startY: pos.y, x: pos.x, y: pos.y };
        selectBox.style.display = 'block';
        selectBox.setAttribute('x', pos.x);
        selectBox.setAttribute('y', pos.y);
        selectBox.setAttribute('width', 0);
        selectBox.setAttribute('height', 0);
      }
    });
    
    document.addEventListener('mousemove', (e) => {
      const pos = screenToCanvas(e.clientX, e.clientY);
      
      // Drawing shape preview
      if (drawing) {
        if (drawing.type === 'line') {
          // Line preview - show actual line with arrow
          const x1 = drawing.startX;
          const y1 = drawing.startY;
          const x2 = pos.x;
          const y2 = pos.y;
          drawPreview.style.display = 'none';
          // Use tempLine for line preview
          const angle = Math.atan2(y2 - y1, x2 - x1);
          const aLen = 10, aWidth = 5;
          const baseX = x2 - Math.cos(angle) * aLen;
          const baseY = y2 - Math.sin(angle) * aLen;
          const px = Math.cos(angle + Math.PI/2) * aWidth;
          const py = Math.sin(angle + Math.PI/2) * aWidth;
          tempPath.setAttribute('d', `M${x1},${y1} L${x2},${y2} M${x2},${y2} L${baseX + px},${baseY + py} M${x2},${y2} L${baseX - px},${baseY - py}`);
          showTempLine();
        } else {
          hideTempLine();
          const x = Math.min(drawing.startX, pos.x);
          const y = Math.min(drawing.startY, pos.y);
          const w = Math.abs(pos.x - drawing.startX);
          const h = Math.abs(pos.y - drawing.startY);
          drawPreview.setAttribute('x', x);
          drawPreview.setAttribute('y', y);
          drawPreview.setAttribute('width', w);
          drawPreview.setAttribute('height', h);
          drawPreview.style.display = 'block';
          // For circle, show square preview
          if (drawing.type === 'circle') {
            const size = Math.max(w, h);
            drawPreview.setAttribute('width', size);
            drawPreview.setAttribute('height', size);
          }
        }
      }
      
      // Dragging node
      if (dragging) {
        dragging.node.x = snap(pos.x - dragging.offsetX);
        dragging.node.y = snap(pos.y - dragging.offsetY);
        if (selectedId === dragging.node.id) positionToolbar(dragging.node);
        render();
      }
      
      // Resizing
      if (resizing) {
        const dx = e.clientX - resizing.startX;
        const dy = e.clientY - resizing.startY;
        resizing.node.width = Math.max(60, snap(resizing.startW + dx / zoom));
        resizing.node.height = Math.max(40, snap(resizing.startH + dy / zoom));
        render();
      }
      
      // Line handle resizing
      if (lineResizing) {
        const node = lineResizing.node;
        if (lineResizing.isStart) {
          // Moving start point - adjust x,y and compensate width/height
          const newX = snap(pos.x);
          const newY = snap(pos.y);
          const endX = lineResizing.origX + lineResizing.origW;
          const endY = lineResizing.origY + lineResizing.origH;
          node.x = newX;
          node.y = newY;
          node.width = endX - newX;
          node.height = endY - newY;
        } else {
          // Moving end point - just adjust width/height
          node.width = snap(pos.x) - node.x;
          node.height = snap(pos.y) - node.y;
        }
        render();
      }
      
      // Drawing connection
      if (connecting) {
        const fromNode = nodes.find(n => n.id === connecting.from);
        let x1, y1;
        
        if (connecting.isLifeline) {
          // For lifeline connections, start from the lifeline center at the clicked Y position
          x1 = fromNode.x + fromNode.width / 2;
          y1 = connecting.lifelineY;
          
          // Check if hovering near same lifeline (self-reference)
          const isSelfRef = Math.abs(pos.x - x1) < 30;
          
          if (isSelfRef) {
            // Show curved loop preview for self-referencing
            const loopWidth = 35;
            const loopHeight = 30;
            const endY = y1 + loopHeight;
            const rightX = x1 + loopWidth;
            const path = `M${x1},${y1} C${rightX},${y1} ${rightX},${endY} ${x1},${endY}`;
            tempPath.setAttribute('d', path);
          } else {
            // Draw a straight horizontal line for sequence messages
            const path = `M${x1},${y1} L${pos.x},${y1}`;
            tempPath.setAttribute('d', path);
          }
        } else {
          // Normal connector - curved path
          [x1, y1] = getConnectorPos(fromNode, connecting.fromSide, connecting.fromIdx);
          const dist = Math.sqrt(Math.pow(pos.x-x1, 2) + Math.pow(pos.y-y1, 2));
          const curveFactor = Math.max(50, dist * 0.4);
          const getOff = (side, f) => {
            switch(side) {
              case 'right': return { x: f, y: 0 };
              case 'left': return { x: -f, y: 0 };
              case 'bottom': return { x: 0, y: f };
              case 'top': return { x: 0, y: -f };
            }
          };
          const off = getOff(connecting.fromSide, curveFactor);
          const path = `M${x1},${y1} C${x1 + off.x},${y1 + off.y} ${pos.x},${pos.y} ${pos.x},${pos.y}`;
          tempPath.setAttribute('d', path);
        }
      }
      
      // Marquee selection
      if (selecting) {
        selecting.x = pos.x;
        selecting.y = pos.y;
        const x = Math.min(selecting.startX, selecting.x);
        const y = Math.min(selecting.startY, selecting.y);
        const w = Math.abs(selecting.x - selecting.startX);
        const h = Math.abs(selecting.y - selecting.startY);
        selectBox.setAttribute('x', x);
        selectBox.setAttribute('y', y);
        selectBox.setAttribute('width', w);
        selectBox.setAttribute('height', h);
      }
      
      // Panning
      if (panning) {
        const dx = (e.clientX - panStart.x) * zoom;
        const dy = (e.clientY - panStart.y) * zoom;
        viewBox.x -= dx;
        viewBox.y -= dy;
        panStart = { x: e.clientX, y: e.clientY };
        updateViewBox();
      }
    });
    
    document.addEventListener('mouseup', (e) => {
      const pos = screenToCanvas(e.clientX, e.clientY);
      
      // Finish drawing shape
      if (drawing) {
        if (drawing.type === 'line') {
          // Line uses start point + delta (width/height can be negative)
          const dx = pos.x - drawing.startX;
          const dy = pos.y - drawing.startY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 20) {
            const node = createNode('line', drawing.startX, drawing.startY, dx, dy);
            saveState();
            render();
            selectNode(node.id);
          }
          
          drawing = null;
          hideTempLine();
          setTool('select');
        } else {
          const x = Math.min(drawing.startX, pos.x);
          const y = Math.min(drawing.startY, pos.y);
          const w = Math.abs(pos.x - drawing.startX);
          const h = Math.abs(pos.y - drawing.startY);
          
          // Only create if dragged at least a little
          if (w > 10 || h > 10) {
            const node = createNode(drawing.type, x, y, w, h);
            saveState();
            render();
            selectNode(node.id);
          }
          
          drawing = null;
          drawPreview.style.display = 'none';
          
          // Switch to select mode after drawing
          setTool('select');
        }
      }
      
      if (dragging) { saveState(); dragging = null; }
      if (resizing) { saveState(); resizing = null; }
      if (lineResizing) { saveState(); lineResizing = null; }
      
      // Finish connection
      if (connecting) {
        const target = document.elementFromPoint(e.clientX, e.clientY);
        
        // Check if we're connecting lifelines (sequence diagram)
        const isLifelineConnection = connecting.isLifeline || target?.classList.contains('lifeline-connector');
        
        if (target?.classList.contains('lifeline-connector')) {
          // Lifeline to lifeline connection - create sequence message
          const toId = target.dataset.node;
          const toLifelineY = parseFloat(target.dataset.lifelineY);
          // Allow self-connections (will render as curved loop)
          const messageY = connecting.lifelineY || toLifelineY || pos.y;
          connections.push({ 
            id: 'c' + Date.now(), 
            from: connecting.from, 
            to: toId, 
            fromSide: 'bottom',
            toSide: 'bottom',
            fromIdx: 1,
            toIdx: 1,
            label: '',
            isSequenceMessage: true,
            messageY: messageY,
            arrow: '->>'
          });
          saveState();
          render();
        } else if (target?.classList.contains('connector')) {
          // Connected to existing node connector
          const toId = target.dataset.node;
          if (toId !== connecting.from) {
            if (connecting.isLifeline) {
              // Lifeline to regular node - create sequence message
              connections.push({ 
                id: 'c' + Date.now(), 
                from: connecting.from, 
                to: toId, 
                fromSide: 'bottom',
                toSide: target.dataset.side,
                fromIdx: 1,
                toIdx: parseInt(target.dataset.idx) || 1,
                label: '',
                isSequenceMessage: true,
                messageY: connecting.lifelineY || pos.y,
                arrow: '->>'
              });
            } else {
              // Regular node to node connection
              connections.push({ 
                id: 'c' + Date.now(), 
                from: connecting.from, 
                fromSide: connecting.fromSide,
                fromIdx: connecting.fromIdx,
                to: toId, 
                toSide: target.dataset.side,
                toIdx: parseInt(target.dataset.idx) || 1,
                lineStyle: globalLineStyle
              });
            }
            saveState();
            render();
          }
        } else if (!target?.closest('.node')) {
          // Released on empty canvas
          if (connecting.isLifeline) {
            // For lifeline connections, just cancel - don't create a node
            // Sequence messages should only connect lifelines
          } else {
            // For regular connections, create new connected node
            const fromNode = nodes.find(n => n.id === connecting.from);
            const newNode = createNode('rect', pos.x - 60, pos.y - 22, 120, 44);
            
            // Determine best sides for connection
            const toSide = getBestConnectorSide(newNode, fromNode.x + fromNode.width/2, fromNode.y + fromNode.height/2);
            
            connections.push({ 
              id: 'c' + Date.now(), 
              from: connecting.from, 
              fromSide: connecting.fromSide,
              fromIdx: connecting.fromIdx,
              to: newNode.id, 
              toSide: toSide,
              toIdx: 1,
              lineStyle: globalLineStyle
            });
            saveState();
            render();
            selectNode(newNode.id);
          }
        }
        
        connecting = null;
        hideTempLine();
        if (currentTool === 'select') canvas.classList.remove('show-connectors');
      }
      
      // Finish marquee selection
      if (selecting) {
        const x = Math.min(selecting.startX, selecting.x);
        const y = Math.min(selecting.startY, selecting.y);
        const w = Math.abs(selecting.x - selecting.startX);
        const h = Math.abs(selecting.y - selecting.startY);
        selectedIds = nodes.filter(n => !(n.x + n.width < x || n.x > x + w || n.y + n.height < y || n.y > y + h)).map(n => n.id);
        if (selectedIds.length === 1) { selectNode(selectedIds[0]); selectedIds = []; }
        else if (selectedIds.length > 1) { selectedId = null; floatingToolbar.classList.add('hidden'); }
        selecting = null;
        selectBox.style.display = 'none';
        render();
      }
      
      if (panning) { panning = false; canvas.style.cursor = 'default'; updateUrlHash(); }
    });
    
    // Debounced URL update for zoom
    let zoomUrlTimer = null;
    
    // Zoom
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? 1.1 : 0.9;
      const newZoom = Math.min(Math.max(zoom * delta, 0.25), 4);
      const wx = viewBox.x + mouseX * zoom;
      const wy = viewBox.y + mouseY * zoom;
      zoom = newZoom;
      viewBox.w = rect.width * zoom;
      viewBox.h = rect.height * zoom;
      viewBox.x = wx - mouseX * zoom;
      viewBox.y = wy - mouseY * zoom;
      updateViewBox();
      // Debounce URL update for zoom
      clearTimeout(zoomUrlTimer);
      zoomUrlTimer = setTimeout(updateUrlHash, 300);
    }, { passive: false });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { deselectAll(); setTool('select'); closeDropdowns(); return; }
      if (e.target.tagName === 'INPUT') return;
      
      // Tool shortcuts
      if (e.key === 'v' || e.key === 'V') { setTool('select'); return; }
      if (e.key === '1') { setTool('rect'); return; }
      if (e.key === '2') { setTool('pill'); return; }
      if (e.key === '3') { setTool('diamond'); return; }
      if (e.key === '4') { setTool('circle'); return; }
      if (e.key === '5') { setTool('container'); return; }
      if (e.key === 't' || e.key === 'T') { setTool('text'); return; }
      if (e.key === '6') { setTool('line'); return; }
      if (e.key === '7') { toggleDropdown('lineDropdown'); return; }
      if (e.key === '8') { toggleGrid(); return; }
      if (e.key === '9') { toggleDropdown('exportDropdown'); return; }
      if (e.key === '0') { shareDiagram(); return; }
      if (e.key === 'a' && !e.ctrlKey && !e.metaKey) { arrangeDiagram(); return; }
      
      // Alt shows connectors temporarily
      if (e.key === 'Alt') canvas.classList.add('show-connectors');
      
      if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
      if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
      if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) { e.preventDefault(); redo(); }
      if ((e.metaKey || e.ctrlKey) && e.key === 'c') { 
        e.preventDefault();
        if (selectedIds.length > 0) clipboard = JSON.stringify(nodes.filter(n => selectedIds.includes(n.id)));
        else if (selectedId) clipboard = JSON.stringify([nodes.find(n => n.id === selectedId)]);
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'v' && clipboard) {
        e.preventDefault();
        const copied = JSON.parse(clipboard);
        const newIds = [];
        copied.forEach(node => { node.id = generateId(); node.x += 20; node.y += 20; nodes.push(node); newIds.push(node.id); });
        saveState();
        selectedIds = newIds;
        selectedId = null;
        render();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      if (e.key === 'Alt' && !connecting && currentTool === 'select') {
        canvas.classList.remove('show-connectors');
      }
    });
    
    // Toolbar label editing
    toolbarLabel.addEventListener('input', (e) => {
      const node = nodes.find(n => n.id === selectedId);
      if (node) { node.label = e.target.value; render(); }
    });
    toolbarLabel.addEventListener('change', saveState);
    toolbarLabel.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') e.target.blur();
      e.stopPropagation();
    });
    
    // Export
    function downloadSVG() {
      const bounds = getContentBounds();
      if (!bounds) {
        alert('Nothing to export!');
        return;
      }
      
      const padding = 40;
      const cropX = bounds.minX - padding;
      const cropY = bounds.minY - padding;
      const cropW = (bounds.maxX - bounds.minX) + padding * 2;
      const cropH = (bounds.maxY - bounds.minY) + padding * 2;
      
      const clone = canvas.cloneNode(true);
      clone.querySelectorAll('.connector, .resize-handle, #selectBox, #drawPreview, .lifeline-connector, .line-handle').forEach(el => el.remove());
      const gridBg = clone.querySelector('#gridBg');
      if (gridBg) gridBg.remove();
      
      // Set viewBox and dimensions to cropped area
      clone.setAttribute('viewBox', `${cropX} ${cropY} ${cropW} ${cropH}`);
      clone.setAttribute('width', cropW);
      clone.setAttribute('height', cropH);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      
      // Add background
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('x', cropX);
      bg.setAttribute('y', cropY);
      bg.setAttribute('width', cropW);
      bg.setAttribute('height', cropH);
      bg.setAttribute('fill', COLORS.bg);
      clone.insertBefore(bg, clone.firstChild);
      
      const blob = new Blob([clone.outerHTML], { type: 'image/svg+xml' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'diagram.svg';
      a.click();
    }
    
    function getContentBounds() {
      if (nodes.length === 0) return null;
      
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      
      // Calculate lifeline height based on sequence messages
      const sequenceMessages = connections.filter(c => c.isSequenceMessage);
      const lifelineHeight = sequenceMessages.length > 0 
        ? Math.max(...sequenceMessages.map(c => c.messageY || 0)) + 80 
        : 300;
      
      // Include all nodes (and their lifelines if applicable)
      nodes.forEach(n => {
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + n.width);
        
        // For nodes with lifelines, extend bounds to include the lifeline
        if (n.isParticipant || n.hasLifeline) {
          maxY = Math.max(maxY, n.y + n.height + lifelineHeight);
        } else {
          maxY = Math.max(maxY, n.y + n.height);
        }
      });
      
      // Include connection labels (they might extend beyond nodes)
      connections.forEach(c => {
        const fromNode = nodes.find(n => n.id === c.from);
        const toNode = nodes.find(n => n.id === c.to);
        if (fromNode && toNode) {
          if (c.isSequenceMessage) {
            // Sequence message - include its Y position and full width
            const y = c.messageY || 150;
            const fromX = fromNode.x + fromNode.width / 2;
            const toX = toNode.x + toNode.width / 2;
            minX = Math.min(minX, Math.min(fromX, toX) - 20);
            maxX = Math.max(maxX, Math.max(fromX, toX) + 20);
            minY = Math.min(minY, y - 25);
            maxY = Math.max(maxY, y + 15);
          } else if (c.label) {
            // Regular connection with label
            const midX = (fromNode.x + fromNode.width/2 + toNode.x + toNode.width/2) / 2;
            const midY = (fromNode.y + fromNode.height/2 + toNode.y + toNode.height/2) / 2;
            minX = Math.min(minX, midX - 50);
            maxX = Math.max(maxX, midX + 50);
            minY = Math.min(minY, midY - 20);
            maxY = Math.max(maxY, midY + 20);
          }
        }
      });
      
      return { minX, minY, maxX, maxY };
    }
    
    function downloadPNG() {
      const bounds = getContentBounds();
      if (!bounds) {
        alert('Nothing to export!');
        return;
      }
      
      const padding = 40;
      const cropX = bounds.minX - padding;
      const cropY = bounds.minY - padding;
      const cropW = (bounds.maxX - bounds.minX) + padding * 2;
      const cropH = (bounds.maxY - bounds.minY) + padding * 2;
      
      const clone = canvas.cloneNode(true);
      clone.querySelectorAll('.connector, .resize-handle, #selectBox, #drawPreview, .lifeline-connector, .line-handle, .conn-hit').forEach(el => el.remove());
      clone.querySelector('#gridBg')?.remove();
      
      // Set viewBox and dimensions to cropped area
      clone.setAttribute('viewBox', `${cropX} ${cropY} ${cropW} ${cropH}`);
      clone.setAttribute('width', cropW);
      clone.setAttribute('height', cropH);
      
      // Embed font style for consistent rendering
      const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
      style.textContent = `text { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }`;
      clone.insertBefore(style, clone.firstChild);
      
      // Also set font-family on all text elements directly
      clone.querySelectorAll('text').forEach(t => {
        t.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif');
      });
      
      const svgData = new XMLSerializer().serializeToString(clone);
      const img = new Image();
      img.onload = () => {
        const scale = 2; // 2x for retina
        const c = document.createElement('canvas');
        c.width = cropW * scale;
        c.height = cropH * scale;
        const ctx = c.getContext('2d');
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.drawImage(img, 0, 0, c.width, c.height);
        const a = document.createElement('a');
        a.href = c.toDataURL('image/png');
        a.download = 'diagram.png';
        a.click();
      };
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }
    
    window.addEventListener('resize', () => {
      const rect = canvas.getBoundingClientRect();
      viewBox.w = rect.width * zoom;
      viewBox.h = rect.height * zoom;
      updateViewBox();
    });
    
    // ===== MERMAID INTEGRATION =====
    let mermaidSyncPaused = false;
    
    function toggleMermaidSidebar() {
      const sidebar = document.getElementById('mermaidSidebar');
      const toggle = document.getElementById('mermaidToggle');
      const isHidden = sidebar.classList.contains('hidden');
      
      if (isHidden) {
        sidebar.classList.remove('hidden');
        sidebar.style.display = 'flex';
        toggle.classList.add('active');
        // Populate with current diagram's Mermaid code
        const editor = document.getElementById('mermaidEditor');
        editor.value = generateMermaid();
        document.getElementById('mermaidError').style.display = 'none';
      } else {
        sidebar.classList.add('hidden');
        sidebar.style.display = 'none';
        toggle.classList.remove('active');
      }
    }
    
    function generateMermaid() {
      if (nodes.length === 0) return 'flowchart TD\n    %% Empty diagram';
      
      // Detect diagram type
      const hasParticipants = nodes.some(n => n.isParticipant || n.hasLifeline);
      const hasSequenceMessages = connections.some(c => c.isSequenceMessage);
      const hasClasses = nodes.some(n => n.isClass);
      
      // Sequence Diagram
      if (hasParticipants || hasSequenceMessages) {
        return generateSequenceMermaid();
      }
      
      // Class Diagram
      if (hasClasses) {
        return generateClassMermaid();
      }
      
      // Default: Flowchart
      return generateFlowchartMermaid();
    }
    
    function generateSequenceMermaid() {
      let code = 'sequenceDiagram\n';
      
      // Get participants in order (by x position) - includes both imported and user-created
      const participants = nodes.filter(n => n.isParticipant || n.hasLifeline).sort((a, b) => a.x - b.x);
      
      // Generate participant definitions
      participants.forEach(p => {
        const keyword = p.isActor ? 'actor' : 'participant';
        const label = (p.label || 'Participant').replace(/"/g, "'");
        // Use sanitized label as ID
        const id = label.replace(/[^a-zA-Z0-9]/g, '');
        code += `    ${keyword} ${id} as ${label}\n`;
      });
      
      code += '\n';
      
      // Build ID map
      const idMap = {};
      participants.forEach(p => {
        const label = (p.label || 'Participant').replace(/"/g, "'");
        idMap[p.id] = label.replace(/[^a-zA-Z0-9]/g, '');
      });
      
      // Get sequence messages sorted by Y position
      const messages = connections
        .filter(c => c.isSequenceMessage)
        .sort((a, b) => (a.messageY || 0) - (b.messageY || 0));
      
      // Generate messages
      messages.forEach(msg => {
        const fromId = idMap[msg.from];
        const toId = idMap[msg.to];
        if (fromId && toId) {
          // Determine arrow type
          let arrow = '->>';
          if (msg.arrow) {
            if (msg.arrow.includes('--')) arrow = '-->>'; // dashed
            if (msg.arrow.includes(')')) arrow = arrow.replace('>>', ')'); // async (open arrow)
          }
          
          const label = msg.label || '';
          code += `    ${fromId}${arrow}${toId}: ${label}\n`;
        }
      });
      
      return code.trim();
    }
    
    function generateClassMermaid() {
      let code = 'classDiagram\n';
      
      // Generate class definitions
      nodes.filter(n => n.isClass).forEach(cls => {
        const name = (cls.label || 'Class').replace(/[^a-zA-Z0-9]/g, '');
        code += `    class ${name} {\n`;
        
        // Properties
        (cls.properties || []).forEach(prop => {
          code += `        ${prop}\n`;
        });
        
        // Methods  
        (cls.methods || []).forEach(method => {
          code += `        ${method}\n`;
        });
        
        code += `    }\n`;
      });
      
      // Build ID map
      const idMap = {};
      nodes.filter(n => n.isClass).forEach(cls => {
        idMap[cls.id] = (cls.label || 'Class').replace(/[^a-zA-Z0-9]/g, '');
      });
      
      // Generate relationships
      connections.forEach(c => {
        const fromId = idMap[c.from];
        const toId = idMap[c.to];
        if (fromId && toId) {
          // Determine relationship type
          let rel = '-->';
          if (c.relType) {
            switch (c.relType) {
              case '<|--': rel = '<|--'; break; // inheritance
              case '--*': rel = '*--'; break; // composition
              case 'o--': rel = 'o--'; break; // aggregation
              default: rel = '-->';
            }
          }
          const label = c.label ? ` : ${c.label}` : '';
          code += `    ${fromId} ${rel} ${toId}${label}\n`;
        }
      });
      
      return code.trim();
    }
    
    function generateFlowchartMermaid() {
      let code = 'flowchart TD\n';
      const nodeIds = {};
      
      // Filter out line/arrow shapes (they're not flowchart nodes)
      const flowNodes = nodes.filter(n => n.type !== 'line');
      
      // Generate node IDs (A, B, C, ...)
      flowNodes.forEach((n, i) => {
        nodeIds[n.id] = String.fromCharCode(65 + (i % 26)) + (i >= 26 ? Math.floor(i / 26) : '');
      });
      
      // Generate node definitions
      flowNodes.forEach(n => {
        const id = nodeIds[n.id];
        const label = (n.label || 'Node').replace(/"/g, "'");
        let shape;
        switch (n.type) {
          case 'pill': shape = `(${label})`; break;
          case 'diamond': shape = `{${label}}`; break;
          case 'circle': shape = `((${label}))`; break;
          case 'container': shape = `[["${label}"]]`; break;
          case 'text': shape = `>${label}]`; break;
          default: shape = `[${label}]`;
        }
        code += `    ${id}${shape}\n`;
      });
      
      // Generate connections (excluding sequence messages)
      const flowConnections = connections.filter(c => !c.isSequenceMessage);
      if (flowConnections.length > 0) {
        code += '\n';
        flowConnections.forEach(c => {
          const fromId = nodeIds[c.from];
          const toId = nodeIds[c.to];
          if (fromId && toId) {
            const label = c.label ? `|${c.label}|` : '';
            code += `    ${fromId} -->${label} ${toId}\n`;
          }
        });
      }
      
      return code.trim();
    }
    
    function parseMermaid(code) {
      const lines = code.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('%%'));
      
      // Detect diagram type
      const firstLine = lines[0] || '';
      if (firstLine.match(/^classDiagram/i)) {
        return parseClassDiagram(lines.slice(1));
      }
      if (firstLine.match(/^sequenceDiagram/i)) {
        return parseSequenceDiagram(lines.slice(1));
      }
      
      // Default: flowchart
      return parseFlowchart(lines);
    }
    
    function parseSequenceDiagram(lines) {
      const result = { nodes: [], connections: [], errors: [], diagramType: 'sequence', frames: [] };
      const participantMap = {};
      const participantOrder = [];
      let messageIndex = 0;
      const frameStack = []; // Track nested frames
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        
        // Participant definition: participant Alice or participant Alice as A
        let m = line.match(/^participant\s+(\w+)(?:\s+as\s+(.+))?$/);
        if (m) {
          const id = m[1];
          const label = m[2] || m[1];
          if (!participantMap[id]) {
            participantMap[id] = { id, type: 'participant', label };
            participantOrder.push(id);
          }
          continue;
        }
        
        // Actor definition: actor Alice
        m = line.match(/^actor\s+(\w+)(?:\s+as\s+(.+))?$/);
        if (m) {
          const id = m[1];
          const label = m[2] || m[1];
          if (!participantMap[id]) {
            participantMap[id] = { id, type: 'actor', label };
            participantOrder.push(id);
          }
          continue;
        }
        
        // Frame start: loop, alt, opt, par
        m = line.match(/^(loop|alt|opt|par)\s+(.*)$/);
        if (m) {
          frameStack.push({
            type: m[1],
            label: m[2],
            startIndex: messageIndex,
            sections: [{ label: m[2], startIndex: messageIndex }]
          });
          continue;
        }
        
        // Else section in alt
        m = line.match(/^else\s*(.*)$/);
        if (m && frameStack.length > 0) {
          const currentFrame = frameStack[frameStack.length - 1];
          if (currentFrame.sections) {
            currentFrame.sections[currentFrame.sections.length - 1].endIndex = messageIndex - 1;
            currentFrame.sections.push({ label: m[1] || 'else', startIndex: messageIndex });
          }
          continue;
        }
        
        // Frame end
        if (line === 'end' && frameStack.length > 0) {
          const frame = frameStack.pop();
          frame.endIndex = messageIndex - 1;
          if (frame.sections) {
            frame.sections[frame.sections.length - 1].endIndex = messageIndex - 1;
          }
          result.frames.push(frame);
          continue;
        }
        
        // Message: Alice->>Bob: Hello or Alice-->>Bob: Hi or Alice-)Bob: Async
        // Also handles activation: Alice->>+Bob or Bob-->>-Alice
        m = line.match(/^(\w+)\s*(->>|-->>|-\)|--\)|->|-->)([+-])?\s*(\w+)\s*:\s*(.*)$/);
        if (m) {
          const [, from, arrow, activation, to, message] = m;
          // Note: activation (+/-) is parsed but not rendered yet (future: activation boxes)
          
          // Auto-create participants if not defined
          if (!participantMap[from]) {
            participantMap[from] = { id: from, type: 'participant', label: from };
            participantOrder.push(from);
          }
          if (!participantMap[to]) {
            participantMap[to] = { id: to, type: 'participant', label: to };
            participantOrder.push(to);
          }
          
          result.connections.push({
            from,
            to,
            label: message,
            arrow,
            index: messageIndex++
          });
          continue;
        }
        
        // Note: Note over Alice,Bob: text or Note right of Alice: text
        // Skip for now - could add later
        if (line.startsWith('Note ')) continue;
        
        // Activation: activate/deactivate - skip for now
        if (line.startsWith('activate ') || line.startsWith('deactivate ')) continue;
      }
      
      // Order nodes by their order of appearance
      result.nodes = participantOrder.map(id => participantMap[id]);
      return result;
    }
    
    function parseClassDiagram(lines) {
      const result = { nodes: [], connections: [], errors: [], diagramType: 'class' };
      const classMap = {};
      let currentClass = null;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        
        // Class definition start: class ClassName {
        let m = line.match(/^class\s+(\w+)\s*\{?$/);
        if (m) {
          currentClass = m[1];
          if (!classMap[currentClass]) {
            classMap[currentClass] = { id: currentClass, type: 'class', label: currentClass, properties: [], methods: [] };
          }
          continue;
        }
        
        // Class definition end
        if (line === '}') {
          currentClass = null;
          continue;
        }
        
        // Inside class definition - property or method
        if (currentClass && classMap[currentClass]) {
          const memberMatch = line.match(/^([+\-#~])?(.+)$/);
          if (memberMatch) {
            const visibility = memberMatch[1] || '+';
            const member = memberMatch[2].trim();
            if (member.includes('(')) {
              classMap[currentClass].methods.push(visibility + member);
            } else {
              classMap[currentClass].properties.push(visibility + member);
            }
          }
          continue;
        }
        
        // Relationship: ClassA <|-- ClassB (inheritance)
        // ClassA *-- ClassB (composition), ClassA o-- ClassB (aggregation)
        // ClassA --> ClassB (association), ClassA -- ClassB (link)
        const relMatch = line.match(/^(\w+)\s*(<\|--|--\*|o--|-->|--)\s*(\w+)(?:\s*:\s*(.+))?$/);
        if (relMatch) {
          const [, from, relType, to, label] = relMatch;
          // Ensure both classes exist
          if (!classMap[from]) classMap[from] = { id: from, type: 'class', label: from, properties: [], methods: [] };
          if (!classMap[to]) classMap[to] = { id: to, type: 'class', label: to, properties: [], methods: [] };
          
          result.connections.push({
            from: from,
            to: to,
            label: label || '',
            relType: relType
          });
          continue;
        }
        
        // Property/method on class: ClassName : +propertyName or ClassName : +methodName()
        const propMatch = line.match(/^(\w+)\s*:\s*([+\-#~])?(.+)$/);
        if (propMatch) {
          const [, className, visibility, member] = propMatch;
          if (!classMap[className]) classMap[className] = { id: className, type: 'class', label: className, properties: [], methods: [] };
          const vis = visibility || '+';
          if (member.includes('(')) {
            classMap[className].methods.push(vis + member.trim());
          } else {
            classMap[className].properties.push(vis + member.trim());
          }
          continue;
        }
      }
      
      result.nodes = Object.values(classMap);
      return result;
    }
    
    function parseFlowchart(lines) {
      const result = { nodes: [], connections: [], errors: [], diagramType: 'flowchart' };
      const nodeMap = {};
      
      // Helper to parse a node token like "A", "A[Label]", "A{Label}", "A((Label))", "A(Label)"
      function parseNodeToken(token) {
        token = token.trim();
        
        // A((circle))
        let m = token.match(/^(\w+)\(\((.+)\)\)$/);
        if (m) return { id: m[1], type: 'circle', label: m[2] };
        
        // A[["container"]]
        m = token.match(/^(\w+)\[\["?(.+?)"?\]\]$/);
        if (m) return { id: m[1], type: 'container', label: m[2] };
        
        // A[rect]
        m = token.match(/^(\w+)\[(.+)\]$/);
        if (m) return { id: m[1], type: 'rect', label: m[2] };
        
        // A{diamond}
        m = token.match(/^(\w+)\{(.+)\}$/);
        if (m) return { id: m[1], type: 'diamond', label: m[2] };
        
        // A(pill)
        m = token.match(/^(\w+)\((.+)\)$/);
        if (m) return { id: m[1], type: 'pill', label: m[2] };
        
        // Just ID
        m = token.match(/^(\w+)$/);
        if (m) return { id: m[1], type: 'rect', label: m[1] };
        
        return null;
      }
      
      // Skip flowchart directive
      let startIdx = 0;
      if (lines[0]?.match(/^flowchart\s+(TD|TB|LR|RL|BT)/i)) {
        startIdx = 1;
      }
      
      // Parse each line
      for (let i = startIdx; i < lines.length; i++) {
        const line = lines[i];
        
        // Skip subgraph, style, class
        if (line.startsWith('subgraph') || line === 'end' || 
            line.startsWith('style') || line.startsWith('class')) continue;
        
        // Connection pattern: NodeA --> NodeB or NodeA -->|label| NodeB
        // Where NodeA/NodeB can be "A" or "A[Label]" or "A{Label}" etc
        const connMatch = line.match(/^(.+?)\s*(-->|---|-\.-|==>)\s*(\|([^|]*)\|)?\s*(.+)$/);
        if (connMatch) {
          const fromToken = connMatch[1].trim();
          const toToken = connMatch[5].trim();
          const label = connMatch[4] || '';
          
          const fromNode = parseNodeToken(fromToken);
          const toNode = parseNodeToken(toToken);
          
          if (fromNode && toNode) {
            // Register nodes if new or update if has more info
            if (!nodeMap[fromNode.id] || nodeMap[fromNode.id].label === fromNode.id) {
              nodeMap[fromNode.id] = fromNode;
            }
            if (!nodeMap[toNode.id] || nodeMap[toNode.id].label === toNode.id) {
              nodeMap[toNode.id] = toNode;
            }
            
            result.connections.push({
              from: fromNode.id,
              to: toNode.id,
              label: label
            });
          }
          continue;
        }
        
        // Standalone node definition
        const node = parseNodeToken(line);
        if (node) {
          nodeMap[node.id] = node;
        }
      }
      
      result.nodes = Object.values(nodeMap);
      return result;
    }
    
    function layoutNodes(parsedNodes, diagramType) {
      const startX = 100;
      const startY = 100;
      
      // Sequence diagram: horizontal layout at top
      if (diagramType === 'sequence') {
        const spacingX = 150;
        return parsedNodes.map((n, i) => ({
          ...n,
          x: startX + i * spacingX,
          y: startY
        }));
      }
      
      // Class diagram: wider spacing
      if (diagramType === 'class') {
        const cols = Math.ceil(Math.sqrt(parsedNodes.length));
        return parsedNodes.map((n, i) => ({
          ...n,
          x: startX + (i % cols) * 220,
          y: startY + Math.floor(i / cols) * 180
        }));
      }
      
      // Default: grid layout
      const cols = Math.ceil(Math.sqrt(parsedNodes.length));
      return parsedNodes.map((n, i) => ({
        ...n,
        x: startX + (i % cols) * 180,
        y: startY + Math.floor(i / cols) * 120
      }));
    }
    
    function exportMermaid() {
      const editor = document.getElementById('mermaidEditor');
      const errorDiv = document.getElementById('mermaidError');
      
      if (nodes.length > 0) {
        editor.value = generateMermaid();
        errorDiv.style.display = 'none';
      } else {
        errorDiv.textContent = 'No diagram to export';
        errorDiv.style.display = 'block';
      }
    }
    
    function importMermaid() {
      const editor = document.getElementById('mermaidEditor');
      const code = editor.value.trim();
      const errorDiv = document.getElementById('mermaidError');
      
      if (!code || code === 'flowchart TD' || code === 'flowchart TD\n    %% Empty diagram') {
        errorDiv.textContent = 'No code to import';
        errorDiv.style.display = 'block';
        return;
      }
      
      // Confirm if diagram exists
      if (nodes.length > 0) {
        if (!confirm('This will replace your current diagram. Continue?')) {
          return;
        }
      }
      
      try {
        const parsed = parseMermaid(code);
        
        if (parsed.nodes.length === 0) {
          errorDiv.textContent = 'No nodes found in code';
          errorDiv.style.display = 'block';
          return;
        }
        
        errorDiv.style.display = 'none';
        
        // Clear current diagram
        saveState();
        nodes = [];
        connections = [];
        sequenceFrames = [];
        
        // Create nodes with layout
        const layouted = layoutNodes(parsed.nodes, parsed.diagramType);
        const idMap = {};
        const isSequence = parsed.diagramType === 'sequence';
        
        // Store sequence frames for rendering
        if (isSequence && parsed.frames) {
          sequenceFrames = parsed.frames;
        }
        
        layouted.forEach(n => {
          // For class diagrams, create wider/taller nodes
          const isClass = n.type === 'class';
          const isParticipant = n.type === 'participant' || n.type === 'actor';
          
          let width, height;
          if (isClass) {
            width = 160;
            height = Math.max(80, 40 + (n.properties?.length || 0) * 16 + (n.methods?.length || 0) * 16);
          } else if (isParticipant) {
            width = 100;
            height = 40;
          }
          
          const nodeType = isParticipant ? 'rect' : (isClass ? 'rect' : n.type);
          const node = createNode(nodeType, n.x, n.y, width, height);
          node.label = n.label;
          
          // Store class properties/methods
          if (isClass) {
            node.isClass = true;
            node.properties = n.properties || [];
            node.methods = n.methods || [];
          }
          
          // Mark as sequence participant with lifeline
          if (isParticipant) {
            node.isParticipant = true;
            node.hasLifeline = true;  // Enable lifeline for UI
            node.isActor = n.type === 'actor';
          }
          
          idMap[n.id] = node.id;
        });
        
        // Create connections
        if (isSequence) {
          // Sequence diagram: messages at different Y levels
          const messageSpacing = 50;
          // Calculate startY based on actual node positions (below the tallest node)
          const participantNodes = nodes.filter(n => n.isParticipant || n.hasLifeline);
          const maxNodeBottom = participantNodes.length > 0 
            ? Math.max(...participantNodes.map(n => n.y + n.height)) 
            : 140;
          const startY = maxNodeBottom + 30; // 30px padding below nodes
          
          parsed.connections.forEach((c, idx) => {
            if (idMap[c.from] && idMap[c.to]) {
              const fromNode = nodes.find(n => n.id === idMap[c.from]);
              const toNode = nodes.find(n => n.id === idMap[c.to]);
              if (fromNode && toNode) {
                connections.push({
                  id: generateId(),
                  from: idMap[c.from],
                  to: idMap[c.to],
                  fromSide: 'bottom',
                  toSide: 'bottom',
                  fromIdx: 1,
                  toIdx: 1,
                  label: c.label || '',
                  isSequenceMessage: true,
                  messageY: startY + idx * messageSpacing,
                  arrow: c.arrow || '->>',
                  index: c.index
                });
              }
            }
          });
        } else {
          // Regular connections
          parsed.connections.forEach(c => {
            if (idMap[c.from] && idMap[c.to]) {
              const fromNode = nodes.find(n => n.id === idMap[c.from]);
              const toNode = nodes.find(n => n.id === idMap[c.to]);
              if (fromNode && toNode) {
                const { fromSide, toSide } = getOptimalSides(fromNode, toNode);
                connections.push({
                  id: generateId(),
                  from: idMap[c.from],
                  to: idMap[c.to],
                  fromSide,
                  toSide,
                  fromIdx: 1,
                  toIdx: 1,
                  label: c.label || '',
                  relType: c.relType
                });
              }
            }
          });
        }
        
        // Ensure nodes are fully created before arranging
        saveState();
        render();
        arrangeDiagram();
        
      } catch (e) {
        errorDiv.textContent = 'Parse error: ' + e.message;
        errorDiv.style.display = 'block';
      }
    }
    
    function updateMermaidEditor() {
      if (mermaidSyncPaused) return;
      const sidebar = document.getElementById('mermaidSidebar');
      if (sidebar.classList.contains('hidden')) return;
      
      const editor = document.getElementById('mermaidEditor');
      editor.value = generateMermaid();
    }
    
    // Add keyboard shortcut for Mermaid toggle
    document.addEventListener('keydown', (e) => {
      if (e.key === 'm' && !e.ctrlKey && !e.metaKey && !e.altKey && 
          !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
        toggleMermaidSidebar();
      }
      // Ctrl+Enter to import Mermaid
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey) && 
          document.activeElement.id === 'mermaidEditor') {
        e.preventDefault();
        importMermaid();
      }
    });
    
    init();
  </script>
</body>
</html>
